---
title: "GTEx transcriptomes: alignment to organ metabolic preferences"
author: "John Mulvey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_notebook:
    toc: yes
    toc_float: yes
    number_sections: yes
    theme: flatly
    highlight: tango
  html_document:
    toc: yes
    df_print: paged
---

Marleen's project involves comparing the expression of components of metabolic 


pathways in different organs, to help interpretation of the fact the metabolism is very different between different tissues (here skeletal muscle, heart and kidney since we have metabolite A-V difference data between the organs). There a a couple of datasets containing both proteome and transcriptome but not with coverage of these 3 tissues. Hence we shall use data from the GTEx resource and then cross correlate the transcript data against (older) MS proteomics datasets for verification.

Normalisation between different tissues is challenging, particularly for sequencing data where high abundance transcripts end up contributing an overrepresetnative number of reads. TMM ("trimmed mean of M values") normalisation was developed for exactly this purpose:

Robinson, M.D., Oshlack, A. A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biol 11, R25 (2010). https://doi.org/10.1186/gb-2010-11-3-r25

GTEx data is expressed as TPM and median normalised, which is less appropriate for our use case. Here I import a Gene TPM dataset downloaded from GTEx and use edgeR for TMM normalisation (i.e. effectively an adjustment in library size???)
GTEx V8 dbGaP Accession phs000424.v8.p2

Info on the GTEx data processing pipeline is available here: https://gtexportal.org/home/documentationPage#staticTextAnalysisMethods

In summary:

RNA-seq Alignment

Alignment to the human reference genome GRCh38/hg38 was performed using STAR v2.5.3a, based on the GENCODE v26 annotation. Unaligned reads were kept in the final BAM file. Among multi-mapping reads, one read is flagged as the primary alignment by STAR. The alignment pipeline is available at https://github.com/broadinstitute/gtex-pipeline/tree/master/rnaseq 


GTEx dbGaP Release	V8 // GENCODE version	v26

Collapsed Gene Model

Gene-level expression quantification was based on the GENCODE 26 annotation, collapsed to a single transcript model for each gene using a custom isoform collapsing procedure, comprising the following steps:

Exons associated with transcripts annotated as “retained_intron” and “read_through” were excluded.
Exon intervals overlapping within a gene were merged.
The intersections of exon intervals overlapping between genes were excluded.
The remaining exon intervals were mapped to their respective gene identifier and stored in GTF format.
Code for generating the collapsed model is available at https://github.com/broadinstitute/gtex-pipeline/tree/master/gene_model . 

Quantification

Gene-level quantifications: read counts and TPM values were produced with RNA-SeQC v1.1.9 (DeLuca et al., Bioinformatics, 2012 ), using the following read-level filters:

Reads were uniquely mapped (corresponding to a mapping quality of 255 for START BAMs).
Reads were aligned in proper pairs.
The read alignment distance was <=6 (i.e., alignments must not contain more than six non-reference bases).
Reads were fully contained within exon boundaries. Reads overlapping introns were not counted.
These filters were applied using the “-strictMode” flag in RNA-SeQC.

The TPM values that are downloadable have not been normalized or corrected for any covariates.

#Load packages
```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(data.table)
library(edgeR)
library(readxl)
library(corrplot)
library(RColorBrewer)
library(factoextra)
library(FactoMineR)
library(psych)
library(GGally)
library(pheatmap)
library(clusterProfiler)
library(enrichplot)
library(org.Hs.eg.db)
library(ggrepel)
library(biomaRt)
library(ggpointdensity)
library(ggplotify)
```


# read data
## sample_meta
```{r}
# make readable tissue types and add phenotype (stored individually for each subj)
sample_meta = read.delim("../data/GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt") %>%
  mutate(tissue = str_replace_all(SMTSD, "[^[:alnum:]]+", "_") %>%
           str_replace("[:punct:]$", "") %>%
           as.factor()) %>%
  mutate(SUBJID = str_extract(SAMPID, pattern = "GTEX-[:alnum:]*(?=[:punct:])")) %>%
  left_join(read.delim("../data/GTEx_Analysis_v8_Annotations_SubjectPhenotypesDS.txt"), by = "SUBJID")

tissue_types = levels(sample_meta$tissue)

tissues_of_interest = c("Kidney_Cortex", "Kidney_Medulla", "Muscle_Skeletal", "Heart_Left_Ventricle", "Liver") # "Heart_Atrial_Appendage",

# filter for tissuetissue contains >10 samples
n_samples = sample_meta %>%
  group_by(tissue) %>%
  count()
n_samples

# pull IDs of relevant samples
selected_sample_id = sample_meta %>%
  filter(tissue %in% tissues_of_interest &
           SMRIN > 7) %>%
  group_by(tissue) %>%
  filter(n() >10) %>%
  pull(SAMPID)
```


## gene read counts
Base read.delim and tidyverse read_delim are unable to deal with the size of this dataset - producing out of memory errors, but data.table works. Need to read sample_meta first since we use it to specify what samples to load the gene reads for.
## transcript
```{r}
# define subset of columns to load
columns_to_load = read_delim("../data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.gct", skip=2, n_max = 1) %>%
  dplyr::select(any_of(selected_sample_id))

#data.table fread as another alternative
gene_reads_matrix = data.table::fread("../data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.gct", skip=2, select = c("Name", "Description", colnames(columns_to_load))) %>%
  dplyr::select(-Description) %>%
  column_to_rownames("Name")
```


## Retrive gene information from biomart
N.B bu taksing the diff between start position and end position we ignore splicing - since tpm divides gene lenth by 1*10^6 this effect should be small and so adequate for our purposes here
```{r}
#use biomart to get gene legnth
ensg_genes = rownames(gene_reads_matrix)
ensg_genes_clean = str_extract(ensg_genes, "[^\\.]+")

mart <- useMart("ensembl", dataset="hsapiens_gene_ensembl")
#possible_attributes = listAttributes(mart = mart)

human_gene_info = biomaRt::getBM(mart = mart, attributes = c("ensembl_gene_id", "hgnc_symbol", "start_position", "end_position", "description", "transcript_biotype", "chromosome_name")) %>%
  mutate(gene_length = end_position - start_position) %>% 
  filter(ensembl_gene_id %in% ensg_genes_clean) %>%
  filter(!duplicated(ensembl_gene_id))

# construct gene info dataframe
gene_info = gene_reads_matrix %>%
  rownames_to_column("GTEx_ENSG") %>%
  dplyr::select("GTEx_ENSG") %>%
  mutate(ensembl_gene_id = str_extract(GTEx_ENSG, "[^\\.]+")) %>%
  left_join(human_gene_info, by = "ensembl_gene_id")

# check for duplicate genes
n_occur <- data.frame(table(gene_info$GTEx_ENSG))
n_occur[n_occur$Freq > 1,]

n_occur <- data.frame(table(human_gene_info$ensembl_gene_id))
n_occur[n_occur$Freq > 1,]
```


## sample_meta again inc number of samples of each tissue
```{r}
sample_meta = sample_meta %>%
  dplyr::filter(SAMPID %in% colnames(gene_reads_matrix)) %>%
  droplevels()

sample_meta %>%
  group_by(tissue) %>%
  summarise(n = n())
```


### ischaemic time
```{r}
library(ggbeeswarm)

sample_meta %>%
  mutate(SMTSISCH = SMTSISCH/60) %>%
  ggplot(aes(x = tissue, y = SMTSISCH, colour = tissue)) +
    geom_beeswarm() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(y = "Ischaemic Time (hours)") +
  theme_minimal()

# ggsave("../results/plots/ischaemic_time_by_tissue.pdf", width = 10, height = 8)
```

## Mitocarta
```{r}
# Define mitochondrial genes
mitocarta = read.csv("../data/mitocarta/Human.MitoCarta3.0_Human.MitoCarta3.0.csv")

# mitocarta_mito_encoded = mitocarta %>%
#   filter(hg19_Chromosome == "chrM")
# 
# # also using TXCHROM from biomart
# mito_encoded_gene_info = gene_info %>%
#   dplyr::filter(str_detect(description, 'mitochondrially encoded'))
# 
# non_mito_encoded_gene_info = gene_info %>%
#   dplyr::filter(!str_detect(description, 'mitochondrially encoded'))
```


# Filter lowly expressed genes
"by group" collaspes groups into just one representative sample
otherwise leaves all samples as one would expect
```{r}
groups = sample_meta %>%
  filter(SAMPID %in% colnames(gene_reads_matrix)) %>%
  pull(tissue) %>%
  droplevels()

# Creates a DGEList object  - the edgeR class
dgelist = DGEList(counts = gene_reads_matrix,
                    group = groups,
                  genes = gene_info)

# filter lowly-expressed genes:
to_keep = filterByExpr(dgelist, group = groups)
table(to_keep)

dgelist = dgelist[to_keep, , keep.lib.sizes=FALSE]
```


# Normalise
TMM noramlisation paper: [@robinson_2010]
```{r}
dgelist = calcNormFactors(dgelist, method = "TMM")

#dgelist = equalizeLibSizes(dgelist)
```


## calculate TPM: grouped
TPM calc confirmed correct by gordon symthe: https://www.biostars.org/p/388584/ 
```{r}
#TMM
rpkm_grouped_tmm = edgeR::rpkmByGroup(dgelist, log=F, gene.length = dgelist$genes$gene_length) %>%
  na.omit()
tpm_grouped_tmm = t(t(rpkm_grouped_tmm) / colSums(rpkm_grouped_tmm) ) * 1e6

#naive
rpkm_grouped_naive = edgeR::rpkmByGroup(dgelist, log=F, gene.length = dgelist$genes$gene_length) %>%
  na.omit()
tpm_grouped_naive = t(t(rpkm_grouped_naive) / colSums(rpkm_grouped_naive) ) * 1e6

#log2
log_tpm_grouped_tmm = log2(tpm_grouped_tmm + 1e-6) %>%
  as.data.frame()

```


## calc TPM: ungrouped
Note that edgeR::rpkm() uses the _normalised_ effective library sizes and not the raw ones - hence we have taken into account the TMM normalisation
```{r}
#TMM
rpkm_tmm <- edgeR::rpkm(dgelist, log=F, gene.length = dgelist$genes$gene_length) %>%
  na.omit()

tpm_tmm <- t(t(rpkm_tmm) / colSums(rpkm_tmm)) * 1e6

#log2
log_tpm_tmm = log2(tpm_tmm + 1e-6) %>%
  as.data.frame()
```


# Assess normalisation
## Plot log cpm distribtuion
```{r}
log_tpm_tmm_long = log_tpm_tmm %>%
  as.data.frame() %>%
  rownames_to_column("ENSG") %>%
  pivot_longer(!ENSG, names_to = "sample", values_to = "log_tpm_tmm") %>%
  left_join(sample_meta, by = c("sample"="SAMPID"))

#sampleswise density plots
log_tpm_tmm_long %>%
  mutate(sample = fct_relevel(sample, sample_meta$SAMPID)) %>%
  ggplot(aes(x = log_tpm_tmm, group = sample, colour = sample)) +
  geom_density(alpha = 0.4, show.legend = FALSE) +
  xlab("log_tpm_tmm")  +
  ggtitle("log_tpm_tmm samplewise density plots") 

###########################
#Assess norm on RPKM rather thna TPM
log_rpkm_tmm_long = rpkm_tmm %>%
  log2() %>%
  as.data.frame() %>%
  rownames_to_column("ENSG") %>%
  pivot_longer(!ENSG, names_to = "sample", values_to = "log_rpkm_tmm") %>%
  left_join(sample_meta, by = c("sample"="SAMPID"))

#sampleswise density plots
log_rpkm_tmm_long %>%
  mutate(sample = fct_relevel(sample, sample_meta$SAMPID)) %>%
  ggplot(aes(x = log_rpkm_tmm, group = sample, colour = sample)) +
  geom_density(alpha = 0.4, show.legend = FALSE) +
  xlab("log_rpkm_tmm")  +
  ggtitle("log_rpkm_tmm samplewise density plots") 
```


# Write data for Marleen
## all genes
Reminder: we only loaded the tissue types that we had a priori interest in
```{r}
tpm_grouped_tmm %>%
  na.omit() %>%
  as.data.frame() %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(gene_info, by = "GTEx_ENSG") %>%
  dplyr::select(-start_position, -end_position, -gene_length, -
GTEx_ENSG) %>%
  write.csv("../results/data/average_log_tpm_grouped_by_tissue.csv")
```


## predefined genes of interest
```{r}
#updated file from Marleen with a few more genes added
genes_of_interest = read_excel("../data/MdW Protein list based on metabolic clusters incl transporters 23-05-2022.xlsx", "HumanGem NoDupl") %>%
  dplyr::rename(ensembl_gene_id = HumanGem_ENSG) %>%
  dplyr::select(Cluster, ensembl_gene_id)

#ensure correct genes_of_interest is specified below
marleen_df = tpm_grouped_tmm[, colnames(tpm_grouped_tmm) %in% tissues_of_interest] %>%
  na.omit() %>%
  as.data.frame() %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(gene_info, by = "GTEx_ENSG") %>%
  dplyr::select(-start_position, -end_position, -gene_length, -GTEx_ENSG, -description) %>%
  right_join(genes_of_interest, by = "ensembl_gene_id")

write.csv(marleen_df, "../results/data/tpm_grouped_by_tissue_specifed_genes_only.csv")
```


# filter genes
## genes of interest
### filter genes
```{r}
#filter for predefined metabolism relevant genes
log_tpm_tmm_goi = log_tpm_tmm %>%
  as.data.frame() %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(gene_info, by = "GTEx_ENSG") %>%
  dplyr::select(-start_position, -end_position, -gene_length, -GTEx_ENSG, -description, -transcript_biotype, -chromosome_name) %>%
  right_join(genes_of_interest, by = "ensembl_gene_id") %>%
  dplyr::select(-hgnc_symbol, -Cluster) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit()

tpm_tmm_goi = log_tpm_tmm^2
```


## all genes
### protein coding
NB there is no need to exclude protein coding genes before testing for differential expression - according to Gordon Smyth, we can trust the edgeR model and in general he favours providing it with more rather than less information. Later after differential expression testing, filtering is done to only retain protein coding genes. 
```{r}
# protein coding genes only
protein_coding_genes = gene_info %>%
  filter(transcript_biotype == "protein_coding") %>%
  pull(ensembl_gene_id)

protein_coding_log_tpm_tmm = log_tpm_tmm %>%
  rownames_to_column("ensembl_gene_id") %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|"))) %>%
  column_to_rownames("ensembl_gene_id")

# log_tpm_tmm = log_tpm_tmm[rownames(log_tpm_tmm) %in% protein_coding_genes,] %>%
#   as.data.frame() 
# 
# log_tpm_grouped_tmm = log_tpm_grouped_tmm[rownames(log_tpm_grouped_tmm) %in% protein_coding_genes,] %>%
#   as.data.frame() 
```


## average expr per tissue
### predefined goi
```{r}
log_tpm_grouped_tmm_goi = log_tpm_grouped_tmm %>%
  as.data.frame() %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(gene_info, by = "GTEx_ENSG") %>%
  dplyr::select(-start_position, -end_position, -gene_length, -GTEx_ENSG, -description, -transcript_biotype, -chromosome_name) %>%
  right_join(genes_of_interest, by = "ensembl_gene_id") %>%
  column_to_rownames("ensembl_gene_id") %>%
  dplyr::select(-hgnc_symbol, -Cluster)
```


### all genes
#### protein coding
```{r}
#protein coding 
protein_coding_log_tpm_grouped_tmm = log_tpm_grouped_tmm %>%
  rownames_to_column("ensembl_gene_id") %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|"))) %>%
  column_to_rownames("ensembl_gene_id")
```


# EDA
## Correlation plot to assess similarity
We calculate pairwise pearson correlation between samples to check for any outliers.
```{r}
cor_matrix = cor(log_tpm_tmm_goi, use = "pairwise.complete.obs")

corrplot(cor_matrix, method="color", type="upper", order="hclust",
         tl.pos='n',
         is.corr = FALSE)
```


## PCA
### all genes
```{r}
res_pca = PCA(t(log_tpm_tmm), scale.unit=TRUE, ncp=5, graph=F)

fviz_screeplot(res_pca, ncp=10,
               ggtheme = theme_gray())

fviz_pca_ind(res_pca,
             axes = c(1,2),
             habillage = sample_meta$tissue,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Tissue",
             title = "All genes, PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

ggsave("../results/plots/PCA_all_genes_1_vs_2.pdf")

fviz_pca_ind(res_pca,
             axes = c(1,3),
             habillage = sample_meta$tissue,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Tissue",
             title = "All genes, PC1 vs PC3",
             invisible="quali",
             ggtheme = theme_gray())

ggsave("../results/plots/PCA_all_genes_1_vs_3.pdf")

res_pca[["ind"]][["coord"]] %>%
  as.data.frame() %>%
  ggpairs(ggplot2::aes(colour=sample_meta$tissue),
          lower = list(continuous = wrap("points", size=0.1)),
          upper = list(continuous = wrap("cor", size = 2)),
          progress = FALSE)

#ggplot bar chart of varaibles contributing most to comp2
```


#### check covariates
```{r}
#exlude variables with more than 30% missing values
sample_meta_num = sample_meta %>% 
  select_if(is.numeric) %>%
  dplyr::select(where(~mean(is.na(.)) < 0.3)) %>%
  dplyr::select(where(function(x) var(x, na.rm = TRUE) != 0))

pc_correlations = cor(sample_meta_num, res_pca[["ind"]]$coord, 
                      use = "pairwise.complete.obs",
                      method = "spearman") #decision: pearson or spearman

pc_correlations %>%
  as.data.frame() %>%
  rownames_to_column("experimental_variable") %>%
  mutate(experimental_variable = fct_reorder(experimental_variable, abs(Dim.1))) %>%
  pivot_longer(cols = -experimental_variable, names_to = "principal_component", values_to = "cor", ) %>%
  ggplot(aes(x = experimental_variable, y = principal_component, fill = cor)) +
  geom_tile(color = "white") +
 scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
   midpoint = 0, limit = c(-1,1), space = "Lab", 
   name="Correlation") +
  geom_text(aes(label = round(cor, 2)), color = "grey40", size = 3) +
  coord_flip() +
  ggtitle("Spearman r of Principal components \n and relevant varaibles, all samples")

#test for significance
pc_correlations_test = corr.test(sample_meta_num %>% dplyr::select_if(is.numeric), res_pca[["ind"]]$coord, 
                      use = "pairwise",
                      method = "spearman")
#signficiant on PC2 which is spread WITHIN rather than BETWEEN tisue types
pc_correlations_test$p.adj %>% 
  as.data.frame() %>%
  dplyr::filter(Dim.2 < 0.01) %>%
  arrange(Dim.2)

#signficiant on any PC 1-5
pc_correlations_test$p.adj %>% 
  as.data.frame() %>%
  dplyr::filter(if_any(everything(), ~ . < 0.01))
```


```{r}
fviz_pca_ind(res_pca,
             axes = c(1,2),
             col.ind = sample_meta$SMTSISCH,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Ischaemic time",
             title = "PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_minimal())

ggsave("../results/plots/PCA_metabolic_genes_1_vs_2_ischaemic.pdf")

fviz_pca_ind(res_pca,
             axes = c(1,2),
             col.ind = sample_meta$SMRIN,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "RIN",
             title = "PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

fviz_pca_ind(res_pca,
             axes = c(1,2),
             col.ind = sample_meta$SMRRNART,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "rRNA rate",
             title = "PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

fviz_pca_ind(res_pca,
             axes = c(1,2),
             col.ind = sample_meta$SMATSSCR,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Autolysis Score",
             title = "PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_minimal())

ggsave("../results/plots/PCA_metabolic_genes_1_vs_2_autolysis_score.pdf")
```


#### experimental batches?
Both of these have far too mnay levels to be practically useful
```{r}
# fviz_pca_ind(res_pca,
#              axes = c(1,2),
#              habillage = as.factor(sample_meta$SMNABTCH),
#              label = "none", #"ind" to show, with optional
#              repel = TRUE,
#              #addEllipses=TRUE, ellipse.level=0.95,
#              legend.title = "RNA extraction batch",
#              title = "PC1 vs PC2",
#              invisible="quali",
#              ggtheme = theme_gray()) +
#   theme(legend.position = "none")
# 
# fviz_pca_ind(res_pca,
#              axes = c(1,2),
#              habillage = as.factor(sample_meta$SMGEBTCH),
#              label = "none", #"ind" to show, with optional
#              repel = TRUE,
#              #addEllipses=TRUE, ellipse.level=0.95,
#              legend.title = "Sequencing batch",
#              title = "PC1 vs PC2",
#              invisible="quali",
#              ggtheme = theme_gray())+
#   theme(legend.position = "none")
```


### metabolic genes only
```{r}
res_pca_goi = PCA(t(log_tpm_tmm_goi), scale.unit=TRUE, ncp=50, graph=F)

fviz_screeplot(res_pca_goi, ncp=10,
               geom = "bar",
               addlabels = TRUE,
               ggtheme = theme_minimal()) +
  theme(plot.title = element_blank())

ggsave("../results/plots/PCA_metabolic_genes_scree_plot.pdf")

fviz_pca_ind(res_pca_goi,
             axes = c(1,2),
             habillage = sample_meta$tissue,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Tissue",
             title = "Metabolic genes, PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

ggsave("../results/plots/PCA_metabolic_genes_1_vs_2.pdf")

fviz_pca_ind(res_pca_goi,
             axes = c(1,3),
             habillage = sample_meta$tissue,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Tissue",
             title = "Metabolic genes, PC1 vs PC3",
             invisible="quali",
             ggtheme = theme_gray())

ggsave("../results/plots/PCA_metabolic_genes_1_vs_3.pdf")

res_pca_goi[["ind"]][["coord"]] %>%
  as.data.frame() %>%
  dplyr::select(1:5) %>%
  ggpairs(ggplot2::aes(colour=sample_meta$tissue),
          lower = list(continuous = wrap("points", size=0.1)),
          upper = list(continuous = wrap("cor", size = 2)),
          progress = FALSE) +
  theme_bw()

ggsave("../results/plots/PCa_metabolic_genes_scatterplot_first_5.pdf")
```


```{r}
#tSNE
source("https://raw.githubusercontent.com/KlugerLab/FIt-SNE/refs/heads/master/fast_tsne.R")
set.seed(123)

res_tsne = res_pca_goi[["ind"]][["coord"]] %>%
  as.data.frame() %>%
  dplyr::select(1:50) %>%
  as.matrix() %>%
  #t() %>%
  fftRtsne(perplexity = -1,
           theta = 0.5,
           stop_early_exag_iter = 250,
           exaggeration_factor = 12,
           K = 10,
           fast_tsne_path = "/usr/local/FIt-SNE/bin/fast_tsne") %>%
  as.data.frame() %>%
  mutate(SAMPID = rownames(res_pca_goi[["ind"]]$coord)) %>%
  left_join(sample_meta, by = "SAMPID") %>%
  dplyr::rename(tSNE_1 = V1, tSNE_2 = V2)

res_tsne %>%
  ggplot(aes(x = tSNE_1, y = tSNE_2, colour = tissue)) +
  geom_point() +
  theme_minimal()

ggsave("../results/plots/tSNE.pdf")
```



### sensitivity analysis
as requested by reviewers
```{r}
library(caret)

# --- 4. 5-Fold Cross-Validation with STRATIFICATION ---

data_for_pca <- t(log_tpm_tmm_goi) 

# --- ROBUSTNESS CHECK ---
# Ensure the row names of your data matrix exactly match the SAMPID column in your metadata.
# If they don't match, this line will stop the script with an error.
stopifnot(all(rownames(data_for_pca) == sample_meta$SAMPID))

# --- THE KEY CHANGE: STRATIFIED FOLD CREATION ---
set.seed(123) # for reproducibility
# We provide the vector of tissue labels to createFolds.
# It will ensure each tissue is proportionally represented in each fold.
folds <- createFolds(sample_meta$tissue, k = 5, list = TRUE, returnTrain = TRUE)


# Initialize a list to store the PCA coordinates from each fold
list_of_coords <- list()

# Loop through each fold (this part of your code is already excellent)
for (i in 1:length(folds)) {
  # Get the training data for this fold
  train_indices <- folds[[i]]
  train_data <- data_for_pca[train_indices, ]
  
  # Run PCA on the subset
  res_pca_fold <- PCA(train_data, scale.unit = TRUE, ncp = 5, graph = FALSE)
  
  # --- CRITICAL: Align Principal Components ---
  coords_fold <- as.data.frame(res_pca_fold$ind$coord[, 1:3])
  
  for (pc in 1:3) {
    common_samples <- intersect(rownames(data_for_pca), rownames(train_data))
    cor_val <- cor(res_pca_goi$ind$coord[common_samples, pc], 
                   coords_fold[common_samples, pc])
    if (cor_val < 0) {
      coords_fold[, pc] <- coords_fold[, pc] * -1
    }
  }
  
  # Add metadata and store the aligned coordinates
  coords_fold$Sample <- rownames(coords_fold)
  coords_fold$Fold <- paste0("Fold", i)
  list_of_coords[[i]] <- coords_fold
}

# --- 5. Combine and Visualize the Results ---

# Combine all results into a single data frame
all_coords <- bind_rows(list_of_coords)

# Add the tissue information using your specific column name "SAMPID"
all_coords <- all_coords %>%
  left_join(sample_meta, by = c("Sample" = "SAMPID"))

# --- Visualization 2: Boxplots by Tissue (Excellent adaptation for many samples!) ---
# Your choice to plot by `tissue` instead of individual sample is very smart.
# It summarizes the stability for each group, which is much more interpretable.
coords_long <- all_coords %>%
  pivot_longer(cols = c("Dim.1", "Dim.2", "Dim.3"), names_to = "PC", values_to = "Coordinate")

p1 <- ggplot(coords_long, aes(x = tissue, y = Coordinate, fill = tissue)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~PC, scales = "free_y", ncol = 3) +
  labs(
    title = "Distribution of Sample Coordinates by Tissue",
    subtitle = "Each box shows the variability of coordinates for a tissue across 5 cross-validation folds",
    x = "Tissue", y = "Coordinate Value"
  ) +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1))

print(p1)


ggplot(coords_long, aes(x = tissue, y = Coordinate, fill = tissue)) +
  geom_boxplot(outlier.shape = NA) +
  facet_grid(Fold ~ PC, scales = "free_y") +
  labs(
    title = "Stability of PCA Coordinates Across Folds and Dimensions",
    subtitle = "Each panel shows coordinate distributions for a specific fold (row) and principal component (column)",
    x = "Tissue", y = "Coordinate Value"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none", # The fill color is redundant with the x-axis
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8), # May need smaller text for the grid
    strip.text = element_text(face = "bold") # Makes the facet labels stand out
  )
```


```{r}
ggplot(all_coords, aes(x = Dim.1, y = Dim.2, color = tissue)) +
  geom_density_2d(alpha = 0.8) +
  facet_wrap(~Fold) + 
  labs(
    title = "Stability of PCA Structure across 5 Folds, PC1 vs PC2",
    x = "Principal Component 1",
    y = "Principal Component 2"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

ggsave("../results/plots/pca_structure_sensitivity_density_1_2.pdf", width = 7, height = 5)

ggplot(all_coords, aes(x = Dim.1, y = Dim.3, color = tissue)) +
  geom_density_2d(alpha = 0.8) +
  facet_wrap(~Fold) + 
  labs(
    title = "Stability of PCA Structure across 5 Folds, PC1 vs PC3",
    x = "Principal Component 1",
    y = "Principal Component 3"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

ggsave("../results/plots/pca_structure_sensitivity_density_1_3.pdf", width = 7, height = 5)
```


```{r}
# # --- 1. Calculate the Centroid for Each Tissue in Each Fold ---
# centroid_coords <- all_coords %>%
#   group_by(tissue, Fold) %>%
#   summarise(
#     mean_dim1 = mean(Dim.1),
#     mean_dim2 = mean(Dim.2),
#     .groups = 'drop' # Recommended to drop grouping after summarise
#   )
# 
# # --- 2. Visualize the Centroids ---
# # We can also add the full data as a faded background for context.
# p_centroids <- ggplot(centroid_coords, aes(x = mean_dim1, y = mean_dim2, color = tissue)) +
#   # Add the original full PCA ellipses for reference
#   stat_ellipse(data = as.data.frame(res_pca_goi$ind$coord) %>% mutate(tissue = sample_meta$tissue),
#                aes(x = Dim.1, y = Dim.2), type = "norm", linetype = "dashed", alpha = 0.8) +
#   # Plot the centroids from each fold
#   geom_point(size = 4, alpha = 0.9) +
#   # Connect the centroids for the same tissue to see the movement
#   geom_path(aes(group = tissue), alpha = 0.6, linewidth = 0.7) +
#   labs(
#     title = "Stability of Tissue Group Centroids across 5 Folds",
#     subtitle = "Points are the mean PCA coordinates for each tissue in each fold. Dashed lines are 95% confidence ellipses from the full data.",
#     x = "Principal Component 1",
#     y = "Principal Component 2"
#   ) +
#   theme_minimal() +
#   guides(color = guide_legend(title = "Tissue"))
# 
# print(p_centroids)
```


### impact of cell death or realted processes?
```{r}
# Load necessary libraries
library(fgsea)      # For GESECA
library(msigdbr)    # To get gene sets


# Your expression matrix is the primary input 'E', which we assign for clarity
E <- log_tpm_tmm_goi

# Quick check of the dimensions
cat("Expression matrix dimensions (Genes x Samples):", dim(E)[1], "x", dim(E)[2], "\n")

# Fetch all Gene Ontology (GO) gene sets for the relevant species.
# Use "Homo sapiens" or "Mus musculus" as appropriate.
go_pathways_df <- msigdbr(species = "Homo sapiens", category = "C5", subcategory = "GO:BP")

# Now, search for pathways containing our keywords. We'll use case-insensitive searching.
keywords <- "NECROSIS|CELL_DEATH"
cell_death_pathways_df <- go_pathways_df %>%
  filter(grepl(keywords, gs_name, ignore.case = TRUE))

# Let's see what we found
cat("Found", nrow(distinct(cell_death_pathways_df, gs_name)), "gene sets related to cell death/apoptosis/necrosis.\n")
head(distinct(cell_death_pathways_df, gs_name))

# check overlap of genes in cell death pathways with goi
intersect(rownames(E), unique(cell_death_pathways_df$ensembl_gene)) %>%
  length()

# Now, convert this data frame into the list format that geseca requires.
# The list should be named by the pathway name, and each element should be a vector of gene symbols.
pathways <- split(x = cell_death_pathways_df$ensembl_gene, f = cell_death_pathways_df$gs_name)

# Check the first pathway in the list
head(pathways[[1]])

# For reproducibility
set.seed(123)

# Run GESECA analysis
# minSize and maxSize are important parameters
gesecaRes <- geseca(pathways = pathways, 
                    E = E, 
                    minSize = 15, 
                    maxSize = 500) %>%
  arrange(padj)
```


```{r}
# # Get the name of the top pathway
# top_pathway_name <- gesecaRes_sorted$pathway[1]
# 
# cat("Visualizing the top pathway:", top_pathway_name, "\n")
# 
# # To make the plot informative, we can color the samples by tissue.
# # We need to make sure the sample order in `sample_meta` matches the column order in `E`.
# # Let's create an ordered 'conditions' vector.
# sample_order <- colnames(E)
# ordered_meta <- sample_meta[match(sample_order, sample_meta$SAMPID), ]
# 
# plotCoregulationProfile(pathway = pathways[[top_pathway_name]], 
#                         E = E, 
#                         conditions = ordered_meta$tissue,
#                         titles = paste("Top Pathway:", top_pathway_name))
# 
# plotGesecaTable(gesecaRes = gesecaRes_sorted %>% head(10), 
#                 pathways = pathways, 
#                 E = E, 
#                 conditions = ordered_meta$tissue)
```



## heatmaps
### genes of interest, individual samples
```{r, fig.width = 12, fig.height = 15}
pheat_inf_col = sample_meta %>%
  column_to_rownames("SAMPID") %>%
  dplyr::select(tissue)

#show individual samples
pheatmap(as.matrix(log_tpm_tmm_goi),
         scale = "none",
         clustering_method = "ward.D2",
         cluster_rows = T,
         clustering_distance_rows = "euclidean",
         cluster_cols = T,
         clustering_distance_cols = "euclidean",
         show_rownames = FALSE,
         show_colnames = FALSE,
         main = "Heatmap of metabolic gene expression in all samples",
         annotation_col=pheat_inf_col)
```


### genes of interest, average per tissue
arranged by metabolic pathway, and then clsutered within each pathway
```{r}
pathways <- marleen_df$Cluster %>%
  as.factor() %>%
  levels()

# create object to store ordering of genes
goi_order <- data.frame(pathway = character(), ensembl_gene_id = character(), stringsAsFactors = FALSE)

# Iterate over each pathway
for (pathway in pathways) {
  # Get genes of the current pathway
  genes_of_pathway <- marleen_df %>%
    filter(Cluster == pathway &
             ensembl_gene_id %in% rownames(log_tpm_grouped_tmm_goi)) %>%
    pull(ensembl_gene_id)
  
  # Subset the expression data for the current pathway
  expression_of_genes <- log_tpm_grouped_tmm_goi[rownames(log_tpm_grouped_tmm_goi) %in% genes_of_pathway, ] %>%
    drop_na() %>%
    t() %>% 
    scale() %>% 
    t()
  
  # Create a dissimilarity matrix using Euclidean distance
  distance_matrix <- dist(expression_of_genes, method = "euclidean") 
  
  # Perform hierarchical clustering using ward.D2 method
  hclust_result <- hclust(distance_matrix, method = "ward.D2")
  
  ordered_expression <- expression_of_genes[hclust_result$order, ]
  
  # store gene order based upon expression profile
  ordered_df <- data.frame(pathway = pathway, ensembl_gene_id = rownames(ordered_expression), stringsAsFactors = FALSE)
  
  # Append the ordered rows to goi_order
  goi_order <- rbind(goi_order, ordered_df)
}

# plot
goi_order <- goi_order %>%
  mutate(pathway_changes = cumsum(lag(pathway, default = as(pathway[1], class(pathway))) != pathway),
    change_indicator = ifelse(lag(pathway_changes, default = 0) < pathway_changes, 1, 0))

pheat_inf_row = genes_of_interest %>%
  column_to_rownames("ensembl_gene_id") %>%
  dplyr::select(Cluster)

# gene wise z-score
log_tpm_grouped_tmm_goi[goi_order$ensembl_gene_id,] %>%
  pheatmap(scale = "row",
           clustering_method = "ward.D2",
           cluster_rows = FALSE,
           cluster_cols = TRUE,
           clustering_distance_cols = "euclidean",
           show_rownames = FALSE,
           fontsize_col = 5,
           angle_col = 45,
           annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
           gaps_row = which(goi_order$change_indicator == 1)-1,
           main = "Heatmap of metabolic gene expression averaged per tissue, z-score")

# raw expression

log_tpm_grouped_tmm_goi[goi_order$ensembl_gene_id,] %>%
  pheatmap(scale = "none",
           clustering_method = "ward.D2",
           cluster_rows = FALSE,
           cluster_cols = TRUE,
           clustering_distance_cols = "euclidean",
           show_rownames = FALSE,
           fontsize_col = 5,
           angle_col = 45,
           annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
           gaps_row = which(goi_order$change_indicator == 1)-1,
           main = "Heatmap of metabolic gene expression averaged per tissue, expression levels")
```


### mito encoded???
```{r, fig.width = 8}
#use breaks to allow the same colour _scale_ to be used across both unnormalised heatmaps
breaksList = seq(min(log_tpm_grouped_tmm), max(log_tpm_grouped_tmm), by = 1)

# as above, but without mito encoded genes
ensg_mito_encoded = gene_info %>%
  filter(chromosome_name == "MT") %>%
  pull(ensembl_gene_id)

#check filtering strategy before plotting heatmap
log_tpm_grouped_tmm  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>% 
  filter(str_detect(ensembl_gene_id, paste(ensg_mito_encoded, collapse = "|"))) %>%
  mutate(ensembl_gene_id = str_extract(ensembl_gene_id, "[^\\.]+")) %>%
  left_join(gene_info, by = "ensembl_gene_id")

log_tpm_grouped_tmm  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>% 
  filter(str_detect(ensembl_gene_id, paste(ensg_mito_encoded, collapse = "|"))) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit() %>%
  pheatmap(scale = "none",
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   main = "Heatmap of mito encoded gene expression averaged per tissue")
  
log_tpm_grouped_tmm  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>% 
  filter(str_detect(ensembl_gene_id, paste(ensg_mito_encoded, collapse = "|"))) %>%
  mutate(ensembl_gene_id = str_extract(ensembl_gene_id, "[^\\.]+")) %>%
  left_join(gene_info, by = "ensembl_gene_id") %>%
  filter(transcript_biotype == "protein_coding") %>%
  column_to_rownames("ensembl_gene_id") %>%
  dplyr::select(any_of(tissues_of_interest)) %>%
  na.omit() %>%
  pheatmap(scale = "none",
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   main = "Heatmap of mito encoded protein coding gene expression averaged per tissue")

# allow comparison between mitochondrial encoded vs nuclear encoded genes
gene_location_df = log_tpm_grouped_tmm  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>% 
  #filter(str_detect(ensembl_gene_id, paste(ensg_mito_encoded, collapse = "|"))) %>%
  mutate(ensembl_gene_id_clean = str_extract(ensembl_gene_id, "[^\\.]+")) %>%
  left_join(gene_info, by = c("ensembl_gene_id_clean" = "ensembl_gene_id")) %>%
  inner_join(mitocarta, by = c("ensembl_gene_id_clean" = "EnsemblGeneID_mapping_version_20200130")) %>%
  filter(transcript_biotype == "protein_coding") %>%
  mutate(gene_location = case_when(
    hg19_Chromosome == "chrM" ~ "mitochondrial",
         TRUE ~ "nuclear")) %>%
  column_to_rownames("GTEx_ENSG") 

pheat_inf_gene_origin = gene_location_df%>%
  dplyr::select(gene_location)

gene_location_df %>%
  dplyr::select(any_of(tissues_of_interest)) %>%
  na.omit() %>%
  pheatmap(scale = "none",
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
           annotation_row = pheat_inf_gene_origin,
                   main = "Heatmap of nuclear vs mito encoded protein coding gene expression averaged per tissue")

## from goi
log_tpm_grouped_tmm_goi  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>%
  filter(ensembl_gene_id %in% ensg_mito_encoded) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit() %>%
  pheatmap(scale = "none",
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
                   main = "Heatmap of mito encoded metabolic gene expression averaged per tissue")

# non mito encoded genes in predefined genes of interest
log_tpm_grouped_tmm_goi  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>%
  filter(!ensembl_gene_id %in% ensg_mito_encoded) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit() %>%
  pheatmap(scale = "none",
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
                   main = "Heatmap of metabolic gene expression (non-mito encoded) averaged per tissue")
```


### all genes, average per tissue
```{r}
#average expression per tissue
log_tpm_grouped_tmm  %>%
  pheatmap(scale = "row",
                   clustering_method = "ward.D2",
                   cluster_rows = TRUE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = TRUE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   main = "Heatmap of all protein coding gene expression averaged per tissue")
```


# Differential expression
```{r}
#design matrix
design = model.matrix(~ 0 + tissue, data = sample_meta) # + SMNABTCH + SMGEBTCH,
colnames(design) = colnames(design) %>%
  str_replace_all(" ", "") %>%
  str_replace_all("tissue", "") %>%
  str_replace_all("-", "_")

y = estimateDisp(dgelist, design, verbose = TRUE, 
                 tagwise = TRUE,
                 tol=1e-12)


# paste0("Common dispersion: ", y[["common.dispersion"]])


plotBCV(y)
#plotMeanVar(y, show.raw.vars = TRUE, show.tagwise.vars = TRUE, show.binned=TRUE)

# plotMDS(y, method="bcv", col=as.numeric(y$samples$group))
# legend("bottomleft", as.character(unique(y$samples$group)))

# et <- exactTest(y, dispersion = "trended")
# 
# topTags(et)
```


## ANOVA for all tissues
```{r}
pval_threshold  = 0.01
logFC_threshold = 2

fit = glmQLFit(y, design)

#############
# contast matrix 
# contrasts <- makeContrasts(
#   (Heart_Left_Ventricle) - (Kidney_Cortex + Liver + Muscle_Skeletal)/3,
#   Kidney_Cortex- (Heart_Left_Ventricle + Liver + Muscle_Skeletal)/3,
#   Liver- (Heart_Left_Ventricle + Kidney_Cortex + Muscle_Skeletal)/3,
#   Muscle_Skeletal - (Heart_Left_Ventricle + Kidney_Cortex + Liver)/3,
#   levels=colnames(design))

# contrat matrix to explicitly state pairwaise comparisons
contrasts <- makeContrasts(
  Heart_Left_Ventricle - Kidney_Cortex,
  Heart_Left_Ventricle - Liver,
  Heart_Left_Ventricle - Muscle_Skeletal,
  Kidney_Cortex - Liver,
  Kidney_Cortex - Muscle_Skeletal,
  Liver - Muscle_Skeletal,
  levels=colnames(design))


qlf = glmQLFTest(fit, contrast = contrasts, poisson.bound	= TRUE)

sig_anova = qlf$table %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(qlf$genes, by = "GTEx_ENSG") %>%
  mutate(adj_PValue = p.adjust(PValue, method = "BH")) %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|"))) %>%
  filter(adj_PValue < pval_threshold) %>%
  filter(if_any(contains("logFC"), ~ . > logFC_threshold))
```


### heatmap
```{r}
# any genes
log_tpm_tmm_sig_anova = log_tpm_tmm %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% sig_anova$GTEx_ENSG) %>%
  column_to_rownames("GTEx_ENSG")

log_tpm_tmm_grouped_sig_anova = log_tpm_grouped_tmm %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% sig_anova$GTEx_ENSG) %>%
  column_to_rownames("GTEx_ENSG")

log_tpm_tmm_grouped_sig_anova %>%
pheatmap(scale = "row",
                   clustering_method = "ward.D2",
                   cluster_rows = T,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = T,
                   clustering_distance_cols = "euclidean",
                  show_rownames = FALSE,
                   show_colnames = TRUE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
         #annotation_col=pheat_inf_col,
         annotation_names_col = FALSE,
                   main ="Heatmap of all genes significant in any contrast")

# metabolic genes only
log_tpm_tmm_grouped_sig_anova_goi = log_tpm_grouped_tmm_goi %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% sig_anova$ensembl_gene_id) %>%
  column_to_rownames("GTEx_ENSG")

log_tpm_tmm_grouped_sig_anova_goi %>%
  pheatmap(scale = "row",
                   clustering_method = "ward.D2",
                   cluster_rows = T,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = T,
                   clustering_distance_cols = "euclidean",
                  show_rownames = FALSE,
                   show_colnames = TRUE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
         #annotation_col=pheat_inf_col,
         annotation_names_col = FALSE,
                   main ="Heatmap of metabolic genes significant in any contrast")
```


```{r}
# create object to store ordering of genes
goi_order <- data.frame(pathway = character(), ensembl_gene_id = character(), stringsAsFactors = FALSE)

# Iterate over each pathway
for (pathway in pathways) {
  # Get genes of the current pathway
  genes_of_pathway <- marleen_df %>%
    filter(Cluster == pathway &
             ensembl_gene_id %in% rownames(log_tpm_tmm_grouped_sig_anova_goi)) %>%
    dplyr::pull(ensembl_gene_id)
  
  # Subset the expression data for the current pathway
  expression_of_genes <- log_tpm_tmm_grouped_sig_anova_goi [rownames(log_tpm_tmm_grouped_sig_anova_goi ) %in% genes_of_pathway, ] %>%
    drop_na() %>%
    t() %>% 
    scale() %>% 
    t()
  
  # Create a dissimilarity matrix using Euclidean distance
  distance_matrix <- dist(expression_of_genes, method = "euclidean") 
  
  # Perform hierarchical clustering using ward.D2 method
  hclust_result <- hclust(distance_matrix, method = "ward.D2")
  
  ordered_expression <- expression_of_genes[hclust_result$order, ]
  
  # store gene order based upon expression profile
  ordered_df <- data.frame(pathway = pathway, ensembl_gene_id = rownames(ordered_expression), stringsAsFactors = FALSE)
  
  # Append the ordered rows to goi_order
  goi_order <- rbind(goi_order, ordered_df)
}

# plot
goi_order <- goi_order %>%
  mutate(pathway_changes = cumsum(lag(pathway, default = as(pathway[1], class(pathway))) != pathway),
    change_indicator = ifelse(lag(pathway_changes, default = 0) < pathway_changes, 1, 0))

pheat_inf_row = genes_of_interest %>%
  column_to_rownames("ensembl_gene_id") %>%
  dplyr::select(Cluster)

# gene wise z-score
log_tpm_tmm_grouped_sig_anova_goi[goi_order$ensembl_gene_id,] %>%
  pheatmap(scale = "row",
           clustering_method = "ward.D2",
           cluster_rows = FALSE,
           cluster_cols = TRUE,
           clustering_distance_cols = "euclidean",
           show_rownames = FALSE,
           fontsize_col = 8,
           angle_col = 0,
           annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
           gaps_row = which(goi_order$change_indicator == 1)-1,
           border_color = NA) %>%
  as.ggplot() +
  ggtitle("Metabolic genes significant in ANOVA averaged per tissue, z-score")

ggsave("../results/plots/heatmap_genes_of_interest_sig_in_anova.pdf", width = 12)
```



###export results
```{r}
write.csv(log_tpm_tmm_grouped_sig_anova_goi, "../results/data/average_log_tpm_grouped_by_tissue_genes_of_interest_sig_anova_only.csv")
```


## all pairwise comparisons
### free memory
```{r}
rm(rpkm_tmm, tpm_tmm, tpm_tmm_goi, gene_reads_matrix)
```


```{r}
tissues <- c("Heart_Left_Ventricle", "Kidney_Cortex", "Liver", "Muscle_Skeletal")

#prep term2gene for custom metabolic comparisons
term2gene = marleen_df %>%
  mutate(Cluster = as.factor(Cluster)) %>%
  dplyr::select(term = Cluster, gene = ensembl_gene_id)

for (i in 1:(length(tissues)-1)) {
  for (j in (i+1):length(tissues)) {
    tissue1 <- tissues[i]
    tissue2 <- tissues[j]
    
    # Lv vs kidney cortex
    et_comparison <- exactTest(y, pair = c(tissue2, tissue1), dispersion = "trended")
    
    de_comparison <- decideTestsDGE(et_comparison, adjust.method = "BH", p.value = 0.05)
    
    results <- et_comparison$table %>%
      rownames_to_column("GTEx_ENSG") %>%
      left_join(et_comparison$genes, by = "GTEx_ENSG") %>%
      mutate(adj_PValue = p.adjust(PValue, method = "BH"),
             diffexpressed = case_when(adj_PValue  < pval_threshold & abs(logFC) > logFC_threshold ~ TRUE,
                              TRUE ~ FALSE))
    
    assign(paste0(tissue1, "_", tissue2, "_edgeR_results"), results)
    
    # save differential testing results
    results %>%
      filter(ensembl_gene_id %in% marleen_df$ensembl_gene_id) %>%
      dplyr::select(ensembl_gene_id, hgnc_symbol, logFC, PValue, adj_PValue, diffexpressed) %>%
      write.csv(paste0("../results/data/differential_expression/edgeR_results_", tissue1, "_", tissue2, ".csv"))
    
    # GSEA custom metabolic pathways
    ranked_genes <- results %>%
      dplyr::select(logFC, ensembl_gene_id) %>%
      group_by(ensembl_gene_id) %>%
      summarise(logFC = mean(logFC)) %>%
      arrange(desc(logFC)) %>%
      pull(logFC, name = ensembl_gene_id)
    
    gse_metabolic <- GSEA(ranked_genes,
                          TERM2GENE = term2gene,
                          pvalueCutoff = 1,
                          pAdjustMethod = "BH",
                          minGSSize = 10,
                          maxGSSize = 10000,
                          by = "fgsea")
    
    gse_metabolic <- pairwise_termsim(gse_metabolic)
    
    assign(paste0(tissue1, "_", tissue2, "_gse_metabolic"), gse_metabolic)
    
    gse_metabolic@result %>%
      filter(p.adjust < 0.05) %>%
      mutate(ID = fct_reorder(ID, NES)) %>%
      ggplot(aes(x = ID, y = NES, fill = pvalue)) +
      geom_col() +
      coord_flip()
    
    gse_metabolic@result %>%
      ggplot(aes(x = NES, y = -log10(pvalue), label = ID)) +
      geom_point(aes(size = setSize/10)) +
      geom_label_repel(data = gse_metabolic@result %>% filter(-log10(pvalue) > 2),
                       size = 3, max.overlaps = 8)
    
    # GSEA GO:BP
    gse_gobp <- clusterProfiler::gseGO(geneList = ranked_genes,
                                       ont = "BP",
                                       keyType = "ENSEMBL",
                                       minGSSize = 5,
                                       maxGSSize = 800,
                                       pvalueCutoff = 1,
                                       verbose = TRUE,
                                       OrgDb = org.Hs.eg.db,
                                       pAdjustMethod = "fdr")
    
    gse_gobp <- pairwise_termsim(gse_gobp)
    
    assign(paste0(tissue1, "_", tissue2, "_gse_gobp"), gse_gobp)

  }
}
```


### plot differential expression
```{r}
# Loop over each combination of tissues
for (tissue1 in tissues) {
  for (tissue2 in tissues) {
    # Create the object name
    edgeR_results <- paste0(tissue1, "_", tissue2, "_edgeR_results")
    
    # Check if the object exists
    if (exists(edgeR_results)) {
      # Filter the data frame
      edgeR_results_goi <- get(edgeR_results) %>%
        filter(ensembl_gene_id %in% genes_of_interest$ensembl_gene_id)
      
      # Plotting code for all genes
      volano_plot_all_genes <- ggplot(data = get(edgeR_results), aes(x = logFC, y = -log10(PValue))) +
        geom_pointdensity(size = 0.5, show.legend = FALSE) +
        scale_color_gradient(low = '#6baed6', high = '#08306b') +
        geom_point(data = get(edgeR_results) %>% filter(diffexpressed == TRUE), size = 0.5, col = 'red') +
        #geom_label_repel(data = get(edgeR_results) %>% filter(diffexpressed == TRUE), aes(label = hgnc_symbol), size = 3, max.overlaps = 25, show.legend = FALSE) +
        xlab('log2 fold change') +
        labs(col = 'adj.P.Val < 0.05 & abs(logFC) > 2') +
        ggtitle(paste(tissue1, " vs ", tissue2, ": all genes"))
      
      # Print the plot for all genes
      print(volano_plot_all_genes)
      
      # Plotting code for gene of interest
      volano_plot_genes_of_interest <- ggplot(data = edgeR_results_goi, aes(x = logFC, y = -log10(PValue))) +
        geom_pointdensity(size = 0.5, show.legend = FALSE) +
        scale_color_gradient(low = '#6baed6', high = '#08306b') +
        geom_point(data = edgeR_results_goi %>% filter(diffexpressed == TRUE), size = 0.5, col = 'red') +
        #geom_label_repel(data = edgeR_results_goi %>% filter(diffexpressed == TRUE), aes(label = hgnc_symbol), size = 3, max.overlaps = 25, show.legend = FALSE) +
        xlab('log2 fold change') +
        labs(col = 'adj.P.Val < 0.05 & abs(logFC) > 2') +
        ggtitle(paste(tissue1, " vs ", tissue2, ": metabolic genes"))
      
      # Print the plot for gene of interest
      print(volano_plot_genes_of_interest)
      
      ggsave(paste0("../results/plots/volcano", tissue1, "_vs_", tissue2, "_metabolic_genes.pdf"))
      
      # P-value histogram
      pvalue_histogram <- ggplot(data = get(edgeR_results), aes(x = PValue)) +
        geom_histogram(binwidth = 0.025, boundary = 0) +
        ggtitle(paste("p-value histogram:", tissue1, "vs", tissue2))
      
      # Print the p-value histogram
      print(pvalue_histogram)
      
      # MA plot
      ma_plot <- ggplot(data = get(edgeR_results), aes(x = logCPM, y = logFC)) +
        geom_pointdensity(size = 0.5, show.legend = FALSE) +
        scale_color_gradient(low = '#6baed6', high = '#08306b') +
        geom_point(data = get(edgeR_results) %>% filter(diffexpressed == TRUE), size = 0.5, col = 'red') +
        geom_label_repel(data = get(edgeR_results) %>% filter(diffexpressed == TRUE), aes(label = hgnc_symbol), size = 3, max.overlaps = 25, show.legend = FALSE) +
        xlab('log2 mean expression') +
        ylab('log2 fold change') +
        ggtitle(paste("MA plot between", tissue1, "and", tissue2)) +
        geom_hline(yintercept = 0) +
        geom_hline(yintercept = 1, linetype = 'dashed') +
        geom_hline(yintercept = -1, linetype = 'dashed') +
        theme(plot.title = element_text(hjust = 0.5))
      
      # Print the MA plot
      print(ma_plot)
      
      # Barplot logFC
      barplot_logFC <- ggplot(data = get(edgeR_results), aes(x = rank(-logFC), y = logFC)) +
        geom_bar(stat = 'identity', width = 0.5, position = "identity") +
        xlab('Rank of logFC') +
        ylab('logFC') +
        ggtitle(paste(tissue1, " vs ", tissue2, ": Rank of logFC"))
      
      print(barplot_logFC)
    }
  }
}

```


#### check expression of a gene with a very low pval
Gene = COX6a2, very low pval in heart vs liver with higher expression in heart
```{r}
gene = "ENSG00000156885"

log_tpm_tmm_long %>%
  filter(str_detect(ENSG, gene)) %>%
  ggplot(aes(x = tissue, y = log_tpm_tmm, group = tissue)) +
  geom_violin(fill = "darkgrey") +
  ggtitle(paste0("Expression of ", gene, " across tissues"))

log_rpkm_tmm_long %>%
  filter(str_detect(ENSG, gene)) %>%
  ggplot(aes(x = tissue, y = log_rpkm_tmm, group = tissue)) +
  geom_violin(fill = "darkgrey") +
  ggtitle(paste0("Expression of ", gene, " across tissues"))
```


### plot enrichment of custom metabolic pathways
```{r}
# Loop over each combination of tissues
for (tissue1 in tissues) {
  for (tissue2 in tissues) {
    # Create the object name
    object_name <- paste0(tissue1, "_", tissue2, "_gse_metabolic")
    
    # Check if the object exists
    if (exists(object_name)) {
      # Plotting code
      plot_code <- paste0("plot_obj <- ", object_name, "@result %>%
                          mutate(ID = fct_reorder(ID, NES)) %>%
                          ggplot(aes(x = ID, y = NES)) +
                          geom_col(aes(fill = ifelse(p.adjust < 0.05, 'p.adjust < 0.05', 'not significant'))) +
                          coord_flip() +
                          theme(legend.title = element_blank(),
                                axis.title.y = element_blank()) +
                          ggtitle('", tissue1, " vs ", tissue2, " \nenrichment of metabolic pathways')")
      
      # Evaluate the plotting code
      eval(parse(text = plot_code))
      
      # Print the plot
      print(plot_obj)
      
      # Save
      file_name <- paste0("../results/plots/", object_name, ".pdf")
      ggsave(plot_obj, file = file_name, width = 7, height = 5)
      
      write.csv(get(object_name), paste0("../results/data/", object_name, "_results.csv"))
    }
  }
}
```


### plot GO:BP GSEA
```{r}
for (tissue1 in tissues) {
  for (tissue2 in tissues) {
    # Create the object name
    object_name <- paste0(tissue1, "_", tissue2, "_gse_gobp")
    
    # Check if the object exists
    if (exists(object_name)) {
      # dotplot code
      dotplot_code <- paste0("dotplot_obj <- ", object_name, " %>%
                            enrichplot::dotplot(showCategory = 10, split = '.sign', color = 'p.adjust') +
  facet_grid(. ~ factor(.sign, levels = c('suppressed', 'activated'))) +
                          ggtitle('", tissue1, " vs ", tissue2, ": enrichment of GO:BP')")
      
      # Evaluate the plotting code
      eval(parse(text = dotplot_code))
      
      # print the dotplot
      print(dotplot_obj)
      
      ##############

      # emapplot code
      emapplot_code <- paste0("emapplot_obj <- ", object_name, " %>%
                            filter(p.adjust < 0.05) %>%
  emapplot(showCategory = 200,
           cex_label_category = 0.5,
           color = 'NES') +
  scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red') +
                          ggtitle('", tissue1, " vs ", tissue2, ": enrichment of GO:BP')")
      
      # Evaluate the plotting code
      eval(parse(text = emapplot_code))
      
      # print the emapplot
      print(emapplot_obj)
      
    }
  }
}

```


### enrichment of custom metaboic pathways v2
```{r}
# read in and prep pathways/gene relationships
term2gene2 = read.csv("../data/20231009 Key enzymes metabolic pathways LL.csv") %>%
  dplyr::select(term = Pathway, gene = Gene) %>%
  mutate(gene = str_trim(gene, side = "right"))

# check if any genes do not map
term2gene2 %>%
  filter(!gene %in% results$ensembl_gene_id)

# calculate gsea
for (tissue1 in tissues) {
  for (tissue2 in tissues) {
    # Create the object name
    edgeR_results <- paste0(tissue1, "_", tissue2, "_edgeR_results")
    
    # Check if the object exists, then get the relevant ser of results
    if (exists(edgeR_results)) {
      edgeR_results <- get(edgeR_results)
 
      # GSEA using _second_ set of pathways curated by LL
      # GSEA custom metabolic pathways
      ranked_genes <- edgeR_results %>%
        dplyr::select(logFC, ensembl_gene_id) %>%
        group_by(ensembl_gene_id) %>%
        summarise(logFC = mean(logFC)) %>%
        arrange(desc(logFC)) %>%
        pull(logFC, name = ensembl_gene_id)
      
      gse_metabolic2 <- GSEA(ranked_genes,
                            TERM2GENE = term2gene2,
                            pvalueCutoff = 1,
                            pAdjustMethod = "BH",
                            minGSSize = 5,
                            maxGSSize = 10000,
                            by = "fgsea")
      
      gse_metabolic2 <- pairwise_termsim(gse_metabolic2)
      
      assign(paste0(tissue1, "_", tissue2, "_gse_metabolic2"), gse_metabolic2)
      
      p1 = gse_metabolic2@result %>%
        #filter(p.adjust < 0.05) %>%
        mutate(ID = fct_reorder(ID, NES)) %>%
        ggplot(aes(x = ID, y = NES, fill = pvalue)) +
        geom_col() +
        coord_flip() +
      ggtitle(paste0(tissue1, " vs ", tissue2, " enrichment of custom pathways v2"))
      
      print(p1)
      
      p2 = gse_metabolic2@result %>%
        ggplot(aes(x = NES, y = -log10(pvalue), label = ID)) +
        geom_point(aes(size = setSize/10)) +
        geom_label_repel(data = gse_metabolic@result %>% filter(-log10(pvalue) > 2),
                         size = 3, max.overlaps = 8) +
      ggtitle(paste0(tissue1, " vs ", tissue2, " enrichment of custom pathways v2"))
      
      print(p2)
    }
  }
}
```


#### plot enrichment of custom metabolic pathways
```{r}
# Loop over each combination of tissues
for (tissue1 in tissues) {
  for (tissue2 in tissues) {
    # Create the object name
    object_name <- paste0(tissue1, "_", tissue2, "_gse_metabolic2")
    
    # Check if the object exists
    if (exists(object_name)) {
      # Plotting code
      plot_code <- paste0("plot_obj <- ", object_name, "@result %>%
                          mutate(ID = fct_reorder(ID, NES)) %>%
                          ggplot(aes(x = ID, y = NES)) +
                          geom_col(aes(fill = ifelse(p.adjust < 0.05, 'p.adjust < 0.05', 'not significant'))) +
                          coord_flip() +
                          theme(legend.title = element_blank(),
                                axis.title.y = element_blank()) +
                          ggtitle('", tissue1, " vs ", tissue2, " \nenrichment of metabolic pathways')")
      
      # Evaluate the plotting code
      eval(parse(text = plot_code))
      
      # Print the plot
      print(plot_obj)
      
      # Save
      file_name <- paste0("../results/plots/", object_name, ".pdf")
      ggsave(plot_obj, file = file_name, width = 7, height = 5)
      
      write.csv(get(object_name), paste0("../results/data/", object_name, "_results.csv"))
    }
  }
}
```


# save objects
```{r}
objects_to_save = list(sample_meta = sample_meta, 
                    log_tpm_tmm_goi = log_tpm_tmm_goi,
                    log_tpm_grouped_tmm_goi = log_tpm_grouped_tmm_goi) #,gse_gobp = gse_gobp

for(i in names(objects_to_save)){
  saveRDS(objects_to_save[[i]], paste0("../results/", i, ".rds"))
}
```


```{r}
sessionInfo()
```


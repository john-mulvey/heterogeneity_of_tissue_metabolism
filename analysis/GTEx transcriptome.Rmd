---
title: "GTEx data normalisation"
author: "John Mulvey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_notebook:
    toc: yes
    toc_float: yes
    number_sections: yes
    theme: flatly
    highlight: tango
  html_document:
    toc: yes
    df_print: paged
---

Marleen's project involves comparing the expression of components of metabolic pathways in different organs, to help interpretation of the fact the metabolism is very different between different tissues (here skeletal muscle, heart and kidney since we have metabolite A-V difference data between the organs). There a a couple of datasets containing both proteome and transcriptome but not with coverage of these 3 tissues. Hence we shall use data from the GTEx resource and then cross correlate the transcript data against (older) MS proteomics datasets for verification.

Normalisation between different tissues is challenging, particularly for sequencing data where high abundance transcripts end up contributing an overrepresetnative number of reads. TMM ("trimmed mean of M values") normalisation was developed for exactly this purpose:

Robinson, M.D., Oshlack, A. A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biol 11, R25 (2010). https://doi.org/10.1186/gb-2010-11-3-r25

GTEx data is expressed as TPM and median normalised, which is less appropriate for our use case. Here I import a Gene TPM dataset downloaded from GTEx and use edgeR for TMM normalisation (i.e. effectively an adjustment in library size???)
GTEx V8 dbGaP Accession phs000424.v8.p2

Info on the GTEx data processing pipeline is available here: https://gtexportal.org/home/documentationPage#staticTextAnalysisMethods

In summary:

RNA-seq Alignment

Alignment to the human reference genome GRCh38/hg38 was performed using STAR v2.5.3a, based on the GENCODE v26 annotation. Unaligned reads were kept in the final BAM file. Among multi-mapping reads, one read is flagged as the primary alignment by STAR. The alignment pipeline is available at https://github.com/broadinstitute/gtex-pipeline/tree/master/rnaseq 


GTEx dbGaP Release	V8 // GENCODE version	v26

Collapsed Gene Model

Gene-level expression quantification was based on the GENCODE 26 annotation, collapsed to a single transcript model for each gene using a custom isoform collapsing procedure, comprising the following steps:

Exons associated with transcripts annotated as “retained_intron” and “read_through” were excluded.
Exon intervals overlapping within a gene were merged.
The intersections of exon intervals overlapping between genes were excluded.
The remaining exon intervals were mapped to their respective gene identifier and stored in GTF format.
Code for generating the collapsed model is available at https://github.com/broadinstitute/gtex-pipeline/tree/master/gene_model . 

Quantification

Gene-level quantifications: read counts and TPM values were produced with RNA-SeQC v1.1.9 (DeLuca et al., Bioinformatics, 2012 ), using the following read-level filters:

Reads were uniquely mapped (corresponding to a mapping quality of 255 for START BAMs).
Reads were aligned in proper pairs.
The read alignment distance was <=6 (i.e., alignments must not contain more than six non-reference bases).
Reads were fully contained within exon boundaries. Reads overlapping introns were not counted.
These filters were applied using the “-strictMode” flag in RNA-SeQC.

The TPM values that are downloadable have not been normalized or corrected for any covariates.


#Load packagges
```{r}
library(tidyverse)
library(data.table)
library(edgeR)
library(biomaRt)
library(readxl)
library(corrplot)
library(RColorBrewer)
library(factoextra)
library(FactoMineR)
library(psych)
library(GGally)
library(pheatmap)
```


# read data
## sample_meta
```{r}
# make readable tissue types and add phenotype (stored individually for each subj)
sample_meta = read.delim("../data/GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt") %>%
  mutate(tissue = str_replace_all(SMTSD, "[^[:alnum:]]+", "_") %>%
           str_replace("[:punct:]$", "") %>%
           as.factor()) %>%
  mutate(SUBJID = str_extract(SAMPID, pattern = "GTEX-[:alnum:]*(?=[:punct:])")) %>%
  left_join(read.delim("../data/GTEx_Analysis_v8_Annotations_SubjectPhenotypesDS.txt"), by = "SUBJID")



tissue_types = levels(sample_meta$tissue)

tissues_of_interest = c("Kidney_Cortex", "Kidney_Medulla", "Muscle_Skeletal", "Heart_Left_Ventricle", "Heart_Atrial_Appendage", "Liver")

# filter for tissuetissue contains >10 samples
n_samples = sample_meta %>%
  group_by(tissue) %>%
  count()
n_samples

# pull IDs of relevant samples
selected_sample_id = sample_meta %>%
  filter(tissue %in% tissues_of_interest &
           SMRIN > 7) %>%
  group_by(tissue) %>%
  filter(n() >10) %>%
  pull(SAMPID)
```


## gene read counts
Base read.delim and tidyverse read_delim are unable to deal with the size of this dataset - producing out of memory errors, but data.table works. Need to read sample_meta first since we use it to specify what samples to load the gene reads for.
## transcript
```{r}
# define subset of columns to load
columns_to_load = read_delim("../data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.gct", skip=2, n_max = 1) %>%
  dplyr::select(any_of(selected_sample_id))

#data.table fread as another alternative
gene_reads_matrix = data.table::fread("../data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.gct", skip=2, select = c("Name", "Description", colnames(columns_to_load ))) %>%
  dplyr::select(-Description) %>%
  column_to_rownames("Name")
```


## Retrive gene information from biomart
N.B bu taksing the diff between start position and end position we ignore splicing - since tpm divides gene lenth by 1*10^6 this effect should be small and so adequate for our purposes here
```{r}
#use biomart to get gene legnth
ensg_genes = rownames(gene_reads_matrix)
ensg_genes_clean = str_extract(ensg_genes, "[^\\.]+")

mart <- useMart("ensembl", dataset="hsapiens_gene_ensembl")
#possible_attributes = listAttributes(mart = mart)

human_gene_info = biomaRt::getBM(mart = mart, attributes = c("ensembl_gene_id", "hgnc_symbol", "start_position", "end_position", "description", "transcript_biotype", "chromosome_name")) %>%
  mutate(gene_length = end_position - start_position) %>% 
  filter(ensembl_gene_id %in% ensg_genes_clean) %>%
  filter(!duplicated(ensembl_gene_id))

# construct gene info dataframe
gene_info = gene_reads_matrix %>%
  rownames_to_column("GTEx_ENSG") %>%
  dplyr::select("GTEx_ENSG") %>%
  mutate(ensembl_gene_id = str_extract(GTEx_ENSG, "[^\\.]+")) %>%
  left_join(human_gene_info, by = "ensembl_gene_id")

# check for duplicate genes
# n_occur <- data.frame(table(gene_info$GTEx_ENSG))
# n_occur[n_occur$Freq > 1,]
# 
# n_occur <- data.frame(table(human_gene_info$ensembl_gene_id))
# n_occur[n_occur$Freq > 1,]
```


## sample_meta again
```{r}
sample_meta = sample_meta %>%
  dplyr::filter(SAMPID %in% colnames(gene_reads_matrix)) %>%
  droplevels()
```


## Mitocarta
```{r}
# Define mitochondrial genes
mitocarta = read.csv("../data/mitocarta/Human.MitoCarta3.0_Human.MitoCarta3.0.csv")

# mitocarta_mito_encoded = mitocarta %>%
#   filter(hg19_Chromosome == "chrM")
# 
# # also using TXCHROM from biomart
# mito_encoded_gene_info = gene_info %>%
#   dplyr::filter(str_detect(description, 'mitochondrially encoded'))
# 
# non_mito_encoded_gene_info = gene_info %>%
#   dplyr::filter(!str_detect(description, 'mitochondrially encoded'))
```


# Filter lowly expressed genes
"by group" collaspes groups into just one representative sample
otherwise leaves all samples as one would expect
```{r}
groups = sample_meta %>%
  filter(SAMPID %in% colnames(gene_reads_matrix)) %>%
  pull(tissue) %>%
  droplevels()

# Creates a DGEList object  - the edgeR class
dgelist = DGEList(counts = gene_reads_matrix,
                    group = groups,
                  genes = gene_info)

# filter lowly-expressed genes:
to_keep = filterByExpr(dgelist, group = groups)
table(to_keep)

dgelist = dgelist[to_keep, ,keep.lib.sizes=FALSE]
```


# Normalise
TMM noramlisation paper: [@robinson_2010]
```{r}
#TMM normalisation
dgelist_tmm = calcNormFactors(dgelist, method = "TMM")

dgelist_tmm_pseudo = equalizeLibSizes(dgelist_tmm)

#dgelist_tmm = dgelist_tmm_pseudo
# #not used
# # counts per million grouped
# gene_cpm_grouped_tmm = cpmByGroup(dgelist_tmm, log=FALSE, group = groups)
# gene_cpm_grouped_naive = cpmByGroup(dgelist, log=FALSE, group = groups)
# 
# #counts per million
# gene_cpm_tmm = cpm(dgelist_tmm, log = FALSE, group = groups)
```


## calculate TPM 
TPM calc confirmed correct by gordon symthe: https://www.biostars.org/p/388584/ 
```{r}
#TMM
rpkm_grouped_tmm = edgeR::rpkmByGroup(dgelist_tmm, log=F, gene.length = dgelist_tmm$genes$gene_length) %>%
  na.omit()
tpm_grouped_tmm = t(t(rpkm_grouped_tmm) / colSums(rpkm_grouped_tmm) ) * 1e6

#naive
rpkm_grouped_naive = edgeR::rpkmByGroup(dgelist, log=F, gene.length = dgelist$genes$gene_length) %>%
  na.omit()
tpm_grouped_naive = t(t(rpkm_grouped_naive) / colSums(rpkm_grouped_naive) ) * 1e6

#log2
log_tpm_grouped_tmm = log2(tpm_grouped_tmm + 1e-6) %>%
  as.data.frame()

log_tpm_grouped_naive = log2(tpm_grouped_naive + 1e-6) %>%
  as.data.frame()
```


## Digression: Plot comparison of 2 tissues: kidney cortex vs skeletalmuscle
```{r}
#to add: select gnes expressed in both samples???
log_tpm_grouped_tmm_toi = log_tpm_grouped_tmm[,c("Kidney_Cortex", "Muscle_Skeletal")]
log_tpm_grouped_naive_toi = log_tpm_grouped_naive[,c("Kidney_Cortex", "Muscle_Skeletal")]

#MA plot using smoothScatter function
par(mfrow=c(1,2))
for(i in c("log_tpm_grouped_tmm_toi", "log_tpm_grouped_naive_toi")){
  g1 <- get(i)[,1]
  g2 <- get(i)[,2]
  smoothScatter(x = 0.5*(g1+g2), # average expr
                y = g1-g2, # fold change
                xlab = "average log expression",
                ylab = "log fold change",
                main = i)
                #ylim=c(-6,6))
  abline(h=0, col="red")
  abline(h=log2(2), col="red", lty=2)
  abline(h=-log2(2), col="red", lty=2)
}
title("Kidney cortex vs skeletal muscle", line = -1, outer = TRUE, cex.main = 0.75)
```


# calc ungrouped data for downstream analysis
```{r}
#TMM
rpkm_tmm <- edgeR::rpkm(dgelist_tmm, log=F, gene.length = dgelist_tmm$genes$gene_length) %>%
  na.omit()
tpm_tmm <- t(t(rpkm_tmm) / colSums(rpkm_tmm)) * 1e6

#log2
log_tpm_tmm = log2(tpm_tmm + 1e-6) %>%
  as.data.frame()
```


# Assess normalisation
## Plot log cpm distribtuion
```{r}
log_tpm_tmm_long = log_tpm_tmm %>%
  as.data.frame() %>%
  rownames_to_column("ENSG") %>%
  pivot_longer(!ENSG, names_to = "sample", values_to = "log_tpm_tmm")

#sampleswise density plots
log_tpm_tmm_long %>%
  mutate(sample = fct_relevel(sample, sample_meta$SAMPID)) %>%
  ggplot(aes(x = log_tpm_tmm, group = sample, colour = sample)) +
  geom_density(alpha = 0.4, show.legend = FALSE) +
  xlab("log_tpm_tmm")  +
  ggtitle("log_tpm_tmm samplewise density plots") 

###########################
#Assess norm on RPKM rather thna TPM
log_rpmk_tmm_long = rpkm_tmm %>%
  log2() %>%
  as.data.frame() %>%
  rownames_to_column("ENSG") %>%
  pivot_longer(!ENSG, names_to = "sample", values_to = "log_rpkm_tmm")

#sampleswise density plots
log_rpmk_tmm_long %>%
  mutate(sample = fct_relevel(sample, sample_meta$SAMPID)) %>%
  ggplot(aes(x = log_rpkm_tmm, group = sample, colour = sample)) +
  geom_density(alpha = 0.4, show.legend = FALSE) +
  xlab("log_rpkm_tmm")  +
  ggtitle("log_rpkm_tmm samplewise density plots") 

# # samplewise boxplot
# log_tpm_tmm_long %>%
#   mutate(sample = fct_relevel(sample, sample_meta$SAMPID)) %>%
#   ggplot(aes(x = sample, y = log_tpm_tmm)) +
#   geom_boxplot() +
#   #scale_x_discrete(guide = guide_axis(angle = 90)) +
#   ggtitle("log_tpm_tmm samplewise boxplots")  +
#   theme(axis.text.x=element_blank())
```


# Write data for Marleen
## (all genes)
Reminder: we only loaded the tissue types that we had a priori interest in
```{r}
tpm_grouped_tmm %>%
  na.omit() %>%
  as.data.frame() %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(gene_info, by = "GTEx_ENSG") %>%
  dplyr::select(-start_position, -end_position, -gene_length, -
GTEx_ENSG) %>%
  write.csv("../output/average_log_tpm_grouped_by_tissue.csv")
```


## (predefined genes of interest)
```{r}
#updated file from Marleen with a few more genes added
genes_of_interest = read_excel("../data/MdW Protein list based on metabolic clusters incl transporters 23-05-2022.xlsx", "HumanGem NoDupl") %>%
  dplyr::rename(ensembl_gene_id = HumanGem_ENSG) %>%
  dplyr::select(Cluster, ensembl_gene_id)

#ensure correct genes_of_interest is specified below
marleen_df = tpm_grouped_tmm[, colnames(tpm_grouped_tmm) %in% tissues_of_interest] %>%
  na.omit() %>%
  as.data.frame() %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(gene_info, by = "GTEx_ENSG") %>%
  dplyr::select(-start_position, -end_position, -gene_length, -GTEx_ENSG, -description) %>%
  right_join(genes_of_interest, by = "ensembl_gene_id")

write.csv(marleen_df, "../output/tpm_grouped_by_tissue_specifed_genes_only.csv")
```


# filter gene list
## genes of interest
### filter genes
```{r}
#filter for predefined metabolism relevant genes
log_tpm_tmm_goi = log_tpm_tmm %>%
  as.data.frame() %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(gene_info, by = "GTEx_ENSG") %>%
  dplyr::select(-start_position, -end_position, -gene_length, -GTEx_ENSG, -description, -transcript_biotype, -chromosome_name) %>%
  right_join(genes_of_interest, by = "ensembl_gene_id") %>%
  dplyr::select(-hgnc_symbol, -Cluster) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit()

tpm_tmm_goi = log_tpm_tmm^2
```


## all genes
### protein coding
```{r}
# protein coding genes only
protein_coding_genes = gene_info %>%
  filter(transcript_biotype == "protein_coding") %>%
  pull(ensembl_gene_id)

protein_coding_log_tpm_tmm = log_tpm_tmm %>%
  rownames_to_column("ensembl_gene_id") %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|"))) %>%
  column_to_rownames("ensembl_gene_id")
```


## average expr per tissue
### predefined goi
```{r}
log_tpm_grouped_tmm_goi = log_tpm_grouped_tmm %>%
  as.data.frame() %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(gene_info, by = "GTEx_ENSG") %>%
  dplyr::select(-start_position, -end_position, -gene_length, -GTEx_ENSG, -description, -transcript_biotype, -chromosome_name) %>%
  right_join(genes_of_interest, by = "ensembl_gene_id") %>%
  column_to_rownames("ensembl_gene_id") %>%
  dplyr::select(-hgnc_symbol, -Cluster)
```


### all genes
#### protein coding
```{r}
#protein coding 
protein_coding_log_tpm_grouped_tmm = log_tpm_grouped_tmm %>%
  rownames_to_column("ensembl_gene_id") %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|"))) %>%
  column_to_rownames("ensembl_gene_id")
```


# EDA
## Correlation plot to assess similarity
We calculate pairwise pearson correlation between samples to check for any outliers.
```{r}
cor_matrix = cor(log_tpm_tmm_goi, use = "pairwise.complete.obs")

corrplot(cor_matrix, method="color", type="upper", order="hclust",
         tl.col="black", tl.srt=45, tl.cex = 0.5,
         is.corr = F)
```


## PCA
### all genes
```{r}
res_pca = PCA(t(log_tpm_tmm), scale.unit=TRUE, ncp=5, graph=F)

fviz_screeplot(res_pca, ncp=10,
               ggtheme = theme_gray())

fviz_pca_ind(res_pca,
             axes = c(1,2),
             habillage = sample_meta$tissue,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Tissue",
             title = "All genes, PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

fviz_pca_ind(res_pca,
             axes = c(1,3),
             habillage = sample_meta$tissue,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Tissue",
             title = "All genes, PC1 vs PC3",
             invisible="quali",
             ggtheme = theme_gray())

res_pca[["ind"]][["coord"]] %>%
  as.data.frame() %>%
  ggpairs(ggplot2::aes(colour=sample_meta$tissue),
          lower = list(continuous = wrap("points", size=0.1)),
          upper = list(continuous = wrap("cor", size = 2)),
          progress = FALSE)

#ggplot bar chart of varaibles contributing most to comp2
```


#### check covariates
```{r}
#exlude variables with more than 30% missing values
sample_meta_num = sample_meta %>% 
  select_if(is.numeric) %>%
  dplyr::select(where(~mean(is.na(.)) < 0.3)) %>%
  dplyr::select(where(function(x) var(x, na.rm = TRUE) != 0))

pc_correlations = cor(sample_meta_num, res_pca[["ind"]]$coord, 
                      use = "pairwise.complete.obs",
                      method = "spearman") #decision: pearson or spearman

pc_correlations %>%
  as.data.frame() %>%
  rownames_to_column("experimental_variable") %>%
  mutate(experimental_variable = fct_reorder(experimental_variable, abs(Dim.1))) %>%
  pivot_longer(cols = -experimental_variable, names_to = "principal_component", values_to = "cor", ) %>%
  ggplot(aes(x = experimental_variable, y = principal_component, fill = cor)) +
  geom_tile(color = "white") +
 scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
   midpoint = 0, limit = c(-1,1), space = "Lab", 
   name="Correlation") +
  geom_text(aes(label = round(cor, 2)), color = "grey40", size = 3) +
  coord_flip() +
  ggtitle("Spearman r of Principal components \n and relevant varaibles, all samples")

#test for significance
pc_correlations_test = corr.test(sample_meta_num %>% dplyr::select_if(is.numeric), res_pca[["ind"]]$coord, 
                      use = "pairwise",
                      method = "spearman")
#signficiant on PC2 which is spread WITHIN rather than BETWEEN tisue types
pc_correlations_test$p.adj %>% #p.adj shows that only perfusion duration is significantly correlated.
  as.data.frame() %>%
  dplyr::filter(Dim.2 < 0.05) %>%
  arrange(Dim.2)

#signficiant on any PC 1-5
pc_correlations_test$p.adj %>% #p.adj shows that only perfusion duration is significantly correlated.
  as.data.frame() %>%
  dplyr::filter(if_any(everything(), ~ . < 0.05))
```


```{r}
fviz_pca_ind(res_pca,
             axes = c(1,2),
             col.ind = sample_meta$SMATSSCR,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Iscahemic time",
             title = "PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

fviz_pca_ind(res_pca,
             axes = c(1,2),
             col.ind = sample_meta$SMRIN,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "RIN",
             title = "PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

fviz_pca_ind(res_pca,
             axes = c(1,2),
             col.ind = sample_meta$SMRRNART,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "rRNA rate",
             title = "PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

fviz_pca_ind(res_pca,
             axes = c(1,2),
             col.ind = sample_meta$SMNTRART,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             title = "PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())
```



#### experimental batches?
Both of these have far too mnay levels to be practically useful
```{r}
# fviz_pca_ind(res_pca,
#              axes = c(1,2),
#              habillage = as.factor(sample_meta$SMNABTCH),
#              label = "none", #"ind" to show, with optional
#              repel = TRUE,
#              #addEllipses=TRUE, ellipse.level=0.95,
#              legend.title = "RNA extraction batch",
#              title = "PC1 vs PC2",
#              invisible="quali",
#              ggtheme = theme_gray()) +
#   theme(legend.position = "none")
# 
# fviz_pca_ind(res_pca,
#              axes = c(1,2),
#              habillage = as.factor(sample_meta$SMGEBTCH),
#              label = "none", #"ind" to show, with optional
#              repel = TRUE,
#              #addEllipses=TRUE, ellipse.level=0.95,
#              legend.title = "Sequencing batch",
#              title = "PC1 vs PC2",
#              invisible="quali",
#              ggtheme = theme_gray())+
#   theme(legend.position = "none")
```


### marleen genes
```{r}
res_pca_goi = PCA(t(log_tpm_tmm_goi), scale.unit=TRUE, ncp=5, graph=F)

fviz_screeplot(res_pca_goi, ncp=10,
               ggtheme = theme_gray())

fviz_pca_ind(res_pca_goi,
             axes = c(1,2),
             habillage = sample_meta$tissue,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Tissue",
             title = "Metabolic genes, PC1 vs PC2",
             invisible="quali",
             ggtheme = theme_gray())

fviz_pca_ind(res_pca_goi,
             axes = c(1,3),
             habillage = sample_meta$tissue,
             label = "none", #"ind" to show, with optional
             repel = TRUE,
             #addEllipses=TRUE, ellipse.level=0.95,
             legend.title = "Tissue",
             title = "Metabolic genes, PC1 vs PC3",
             invisible="quali",
             ggtheme = theme_gray())

res_pca_goi[["ind"]][["coord"]] %>%
  as.data.frame() %>%
  ggpairs(ggplot2::aes(colour=sample_meta$tissue),
          lower = list(continuous = wrap("points", size=0.1)),
          upper = list(continuous = wrap("cor", size = 2)),
          progress = FALSE)
```


##### ggplot bar chart of varaibles contributing most to comp2
```{r}

```


## heatmaps
### genes of interest, individual samples
```{r, fig.width = 12, fig.height = 15}
pheat_inf_col = sample_meta %>%
  column_to_rownames("SAMPID") %>%
  dplyr::select(tissue)

#show individual samples
pheatmap(as.matrix(log_tpm_tmm_goi),
           scale = "none",
                   clustering_method = "ward.D2",
                   cluster_rows = T,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = T,
                   clustering_distance_cols = "euclidean",
                   show_rownames = TRUE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   main = "Heatmap of metabolic gene expression in all samples",
                   annotation_col=pheat_inf_col)
```


### genes of interest, average per tissue
```{r, fig.width = 8}
pheat_inf_row = genes_of_interest %>%
  column_to_rownames("ensembl_gene_id") %>%
  dplyr::select(Cluster)

#average expression per tissue, cluster genes
log_tpm_grouped_tmm_goi  %>%
  na.omit() %>%
  pheatmap(scale = "row",
                   clustering_method = "ward.D2",
                   cluster_rows = TRUE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
                   main = "Heatmap of metabolic gene expression averaged per tissue, z-score")

# as above, but with gene order defined by metabolic pathways
log_tpm_grouped_tmm_goi  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit() %>%
  pheatmap(scale = "none",
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
                   main = "Heatmap of metabolic gene expression averaged per tissue, z-score")
```


### mito encoded???
```{r, fig.width = 8}
#use breaks to allow the same colour _scale_ to be used across both unnormalised heatmaps
breaksList = seq(min(log_tpm_grouped_tmm), max(log_tpm_grouped_tmm), by = 1)

# as above, but without mito encoded genes
ensg_mito_encoded = gene_info %>%
  filter(chromosome_name == "MT") %>%
  pull(ensembl_gene_id)

#check filtering strategy before plotting heatmap
log_tpm_grouped_tmm  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>% 
  filter(str_detect(ensembl_gene_id, paste(ensg_mito_encoded, collapse = "|"))) %>%
  mutate(ensembl_gene_id = str_extract(ensembl_gene_id, "[^\\.]+")) %>%
  left_join(gene_info, by = "ensembl_gene_id")

log_tpm_grouped_tmm  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>% 
  filter(str_detect(ensembl_gene_id, paste(ensg_mito_encoded, collapse = "|"))) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit() %>%
  pheatmap(scale = "none",
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   main = "Heatmap of mito encoded gene expression averaged per tissue")
  
log_tpm_grouped_tmm  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>% 
  filter(str_detect(ensembl_gene_id, paste(ensg_mito_encoded, collapse = "|"))) %>%
  mutate(ensembl_gene_id = str_extract(ensembl_gene_id, "[^\\.]+")) %>%
  left_join(gene_info, by = "ensembl_gene_id") %>%
  filter(transcript_biotype == "protein_coding") %>%
  column_to_rownames("ensembl_gene_id") %>%
  dplyr::select(Heart_Atrial_Appendage:Muscle_Skeletal) %>%
  na.omit() %>%
  pheatmap(scale = "none",
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   main = "Heatmap of mito encoded protein coding gene expression averaged per tissue")

# allow comparison between mitochondrial encoded vs nuclear encoded genes
gene_lcoation_df = log_tpm_grouped_tmm  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>% 
  #filter(str_detect(ensembl_gene_id, paste(ensg_mito_encoded, collapse = "|"))) %>%
  mutate(ensembl_gene_id_clean = str_extract(ensembl_gene_id, "[^\\.]+")) %>%
  left_join(gene_info, by = c("ensembl_gene_id_clean" = "ensembl_gene_id")) %>%
  inner_join(mitocarta, by = c("ensembl_gene_id_clean" = "EnsemblGeneID_mapping_version_20200130")) %>%
  filter(transcript_biotype == "protein_coding") %>%
  mutate(gene_location = case_when(
    hg19_Chromosome == "chrM" ~ "mitochondrial",
         TRUE ~ "nuclear")) %>%
  column_to_rownames("GTEx_ENSG") 

pheat_inf_gene_origin = gene_lcoation_df%>%
  dplyr::select(gene_location)

gene_lcoation_df %>%
  dplyr::select(Heart_Atrial_Appendage:Muscle_Skeletal) %>%
  na.omit() %>%
  pheatmap(scale = "none",
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
           annotation_row = pheat_inf_gene_origin,
                   main = "Heatmap of nuclear vs mito encoded protein coding gene expression averaged per tissue")

## from goi
log_tpm_grouped_tmm_goi  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>%
  filter(ensembl_gene_id %in% ensg_mito_encoded) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit() %>%
  pheatmap(scale = "none",
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
                   main = "Heatmap of mito encoded metabolic gene expression averaged per tissue")

# non mito encoded genes in predefined genes of interest
log_tpm_grouped_tmm_goi  %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(factor(ensembl_gene_id, levels = genes_of_interest$ensembl_gene_id)) %>%
  filter(!ensembl_gene_id %in% ensg_mito_encoded) %>%
  column_to_rownames("ensembl_gene_id") %>%
  na.omit() %>%
  pheatmap(scale = "none",
                   clustering_method = "ward.D2",
                   cluster_rows = FALSE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   annotation_row = pheat_inf_row,
           annotation_names_row = FALSE,
                   main = "Heatmap of metabolic gene expression (non-mito encoded) averaged per tissue")
```


### all genes, individual samples
```{r, fig.width = 12, fig.height = 15}
# #show individual samples
# pheatmap(as.matrix(log_tpm_tmm),
#            scale = "none",
#                    clustering_method = "ward.D2",
#                    cluster_rows = T,
#                    clustering_distance_rows = "euclidean",
#                    cluster_cols = T,
#                    clustering_distance_cols = "euclidean",
#                    show_rownames = TRUE,
#                    fontsize_row = 3,
#                    fontsize_col = 5,
#                    angle_col = 45,
#                    main = "Heatmap of all protein coding gene expression in all samples",
#                    annotation_col=pheat_inf_col)
```


### all genes, average per tissue
```{r}
#average expression per tissue
log_tpm_grouped_tmm  %>%
  pheatmap(scale = "row",
                   clustering_method = "ward.D2",
                   cluster_rows = TRUE,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = TRUE,
                   clustering_distance_cols = "euclidean",
                   show_rownames = TRUE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
                   main = "Heatmap of all protein coding gene expression averaged per tissue")
```


# batch correction using ComBat
NB in previous versions I have attempted to use surrogate varaible analysis, but results have been impractical - with >1000 varaibles suggested and with very long run times. Using a data driven method to identify clinical/experimental vraibles that contribute most to the highest principle components we remove these for downstream visualisation in e.g. heatmaps.
These corrected varaibles will then be eplicitly included in the design matrix for differential expression testing.
```{r}
# library(sva)
# design = model.matrix(~tissue, data = sample_meta)
# design0 = model.matrix(~ 1, data = sample_meta)
# n_sv = num.sv(dgelist_tmm$counts, mod = design, method = "be")
# sv_obj = svaseq(dgelist_tmm$counts, mod = design, mod0 = design0, n.sv = n_sv)
# design_sv = cbind(design, sv_obj$sv)
# 
# # combat_matrix = ComBat_seq(counts = dgelist_tmm$counts, batch = sv_obj$sv, covar_mod = design)
# # 
# # combat_matrix = ComBat_seq(counts = dgelist_tmm$counts, batch = sv_obj$sv, covar_mod = design)
# 
# #taken from Jaffe lab @ Lieber Institute
# cleaningY <- function(y, mod, P) {
#     stopifnot(P <= ncol(mod))
#     stopifnot("Input matrix is not full rank" = qr(mod)$rank == ncol(mod))
#     Hat <- solve(t(mod) %*% mod) %*% t(mod)
#     ## For dealing with NAs
#     ## https://stackoverflow.com/questions/16535084/matrix-multiplication-with-scattered-na-values
#     ty <- t(y)
#     ty[is.na(ty)] <- 0
#     beta <- (Hat %*% ty)
#     ## Note that y might still have the NAs, and NA - a number = NA
#     ## so there's no need to reset the NAs back on cleany
#     cleany <- y - t(as.matrix(mod[, -c(seq_len(P))]) %*% beta[-seq_len(P), ])
#     return(cleany)
# }
# 
# cleaned_counts = cleaningY(dgelist_tmm$counts, design_sv, P = 5)
# cleaned_counts[cleaned_counts < 0] = 0


# library(sva)
# design = model.matrix(~tissue, data = sample_meta)
# design0 = model.matrix(~ 1, data = sample_meta)
# n_sv = num.sv(dgelist_tmm$counts, mod = design, method = "be")
# sv_obj = svaseq(dgelist_tmm$counts, mod = design, mod0 = design0, n.sv = n_sv)
# design_sv = cbind(design, sv_obj$sv)
```


## using batch info in metadata
```{r}

```


## calc log TPM for batch corrected data
not used, probably can delete?
```{r}
# gene_length_goi = dgelist_tmm$counts %>%
#   as.data.frame() %>%
#   rownames_to_column("GTEx_ENSG") %>%
#   left_join(gene_info, by = "GTEx_ENSG") %>%
#   pull(gene_length)
# 
# #TMM
# rpkm_tmm_clean <- edgeR::rpkm(dgelist_tmm$counts, log=F, gene.length = gene_length_goi ) %>%
#   na.omit()
# tpm_tmm_clean <- t(t(rpkm_tmm_clean) / colSums(rpkm_tmm_clean) ) * 1e6
# 
# #log2
# log_tpm_tmm_clean = log2(tpm_tmm_clean + 1)
# 
# 
# #filter for predefined metabolism relevant genes
# log_tpm_tmm_goi_clean = log_tpm_tmm_clean %>%
#   na.omit() %>%
#   as.data.frame() %>%
#   rownames_to_column("GTEx_ENSG") %>%
#   left_join(gene_info, by = "GTEx_ENSG") %>%
#   dplyr::select(-start_position, -end_position, -gene_length, -GTEx_ENSG, -description, -transcript_biotype, -chromosome_name) %>%
#   right_join(genes_of_interest, by = "ensembl_gene_id") %>%
#   dplyr::select(-ensembl_gene_id, -hgnc_symbol, -Cluster) %>%
#   as.matrix() %>%
#   na.omit()
# 
# tpm_tmm_goi_clean = (log_tpm_tmm_goi_clean^2)-1
```



#batch corrected
## check PCA marleen genes
```{r}
# res_pca_clean = PCA(t(log_tpm_tmm_goi_clean), scale.unit=TRUE, ncp=5, graph=F)
# 
# fviz_screeplot(res_pca_clean, ncp=10,
#                ggtheme = theme_gray())
# 
# fviz_pca_ind(res_pca_clean,
#              axes = c(1,2),
#              habillage = sample_meta$tissue,
#              label = "none", #"ind" to show, with optional
#              repel = TRUE,
#              #addEllipses=TRUE, ellipse.level=0.95,
#              legend.title = "Tissue",
#              title = "PC1 vs PC2",
#              invisible="quali",
#              ggtheme = theme_gray())
# 
# fviz_pca_ind(res_pca_clean,
#              axes = c(1,3),
#              habillage = sample_meta$tissue,
#              label = "none", #"ind" to show, with optional
#              repel = TRUE,
#              #addEllipses=TRUE, ellipse.level=0.95,
#              legend.title = "Tissue",
#              title = "PC1 vs PC3",
#              invisible="quali",
#              ggtheme = theme_gray())
# 
# #ggplot bar chart of varaibles contributing most to comp2
# 
# 
# library(GGally)
# res_pca_clean[["ind"]][["coord"]] %>%
#   as.data.frame() %>%
#   ggpairs(ggplot2::aes(colour=sample_meta$tissue),
#           lower = list(continuous = wrap("points", size=0.1)),
#           upper = list(continuous = wrap("cor", size = 2)))
```


## check PCA all genes
```{r}
# res_pca_all_genes = PCA(t(log_tpm_tmm), scale.unit=TRUE, ncp=5, graph=F)
# 
# fviz_screeplot(res_pca_all_genes, ncp=10,
#                ggtheme = theme_gray())
# 
# fviz_pca_ind(res_pca_all_genes,
#              axes = c(1,2),
#              habillage = sample_meta$tissue,
#              label = "none", #"ind" to show, with optional
#              repel = TRUE,
#              #addEllipses=TRUE, ellipse.level=0.95,
#              legend.title = "Tissue",
#              title = "PC1 vs PC2",
#              invisible="quali",
#              ggtheme = theme_gray())
# 
# fviz_pca_ind(res_pca_all_genes,
#              axes = c(1,3),
#              habillage = sample_meta$tissue,
#              label = "none", #"ind" to show, with optional
#              repel = TRUE,
#              #addEllipses=TRUE, ellipse.level=0.95,
#              legend.title = "Tissue",
#              title = "PC1 vs PC3",
#              invisible="quali",
#              ggtheme = theme_gray())
# 
# #ggpairs plot
# res_pca_all_genes[["ind"]][["coord"]] %>%
#   as.data.frame() %>%
#   ggpairs(ggplot2::aes(colour=sample_meta$tissue),
#           lower = list(continuous = wrap("points", size=0.1)),
#           upper = list(continuous = wrap("cor", size = 2)))
```


# Differential expression
## Heart LV vs Kidney cortex
```{r}
#design matrix
design = model.matrix(~ 0 + tissue, data = sample_meta) # + SMNABTCH + SMGEBTCH,
colnames(design) = colnames(design) %>%
  str_replace_all(" ", "") %>%
  str_replace_all("tissue", "") %>%
  str_replace_all("-", "_")

y = estimateDisp(dgelist_tmm, design, verbose = T)
paste0("Common dispersion: ", y[["common.dispersion"]])


plotBCV(y)
plotMeanVar(y, show.raw.vars = TRUE, show.tagwise.vars = TRUE, show.binned=TRUE)

# plotMDS(y, method="bcv", col=as.numeric(y$samples$group))
# legend("bottomleft", as.character(unique(y$samples$group)))

et <- exactTest(y)
topTags(et)

# Lv vs kidney cortex
et_LV_vs_cortex <- exactTest(y, pair=c("Heart_Left_Ventricle","Kidney_Cortex"))
topTags(et_LV_vs_cortex, n=10)
de_LV_vs_cortex <- decideTestsDGE(et_LV_vs_cortex, adjust.method="BH", p.value=0.05)

LV_vs_cortex_results = et_LV_vs_cortex$table %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(et_LV_vs_cortex$genes, by = "GTEx_ENSG") %>%
  mutate(adj_PValue = p.adjust(PValue, method = "BH"))

LV_vs_cortex_results %>% 
  filter(adj_PValue < 0.05 & abs(logFC) > 5)
```


## Kidney cortex vs liver
```{r}
# kidney cortex vs medulla
et_cortex_vs_liver <- exactTest(y, pair=c("Kidney_Cortex", "Liver"))
  
topTags(et_cortex_vs_liver, n=10)
de_cortex_vs_liver <- decideTestsDGE(et_cortex_vs_liver, adjust.method="BH", p.value=0.01, lfc = 5)

de_cortex_vs_liver_tags <- rownames(y)[as.logical(de_cortex_vs_liver)] 
plotSmear(et_cortex_vs_liver, de.tags=de_cortex_vs_liver_tags)
abline(h = c(-2, 2), col = "blue")

cortex_vs_liver_results = et_cortex_vs_liver$table %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(et_cortex_vs_liver$genes, by = "GTEx_ENSG") %>%
  mutate(adj_PValue = p.adjust(PValue, method = "BH"))

cortex_vs_liver_results %>% 
  filter(adj_PValue < 0.05 & abs(logFC) > 5) %>%
  dim()
```


## Heart LV vs Heart AA
```{r}
fit = glmQLFit(y, design)

contrast_matrix <- makeContrasts(Heart_LeftVentricle_vs_Heart_AtrialAppendage = Heart_Left_Ventricle - Heart_Atrial_Appendage,
                                 levels=design)

# p <- pchisq(fit$dispersion, df=fit$df.residual, lower.tail=FALSE)
# p.holm <- p.adjust(p, method="holm")
# z <- zscoreGamma(fit$dispersion, shape=fit$df.residual/2, scale=2)
# col <- ifelse(p.holm < 0.05, "blue", "black")
# qqnorm(z, col=col, main="Common")
# 
# gof(fit, p=0.05, plot=TRUE, main="Common")

qlf = glmQLFTest(fit, contrast = contrast_matrix[,"Heart_LeftVentricle_vs_Heart_AtrialAppendage"])

decideTestsDGE(qlf, p.value=0.01, lfc=2) %>% 
  summary()


#contrast.matrix <- makeContrasts(Experimental.groupHeart_failure-Experimental.groupControl, levels=design)
```

?treatDGE


```{r}
library(ggrepel)
#quick dirty summary of differential expression
results = topTags(qlf, adjust="fdr", sort.by="p.value", n=nrow(qlf))$table

#volcanoplot
results$diffexpressed = "No"
results$diffexpressed[results$FDR < 0.01 & abs(results$logFC) > 2] = "Yes"
results$DElabel <- NA
results$DElabel[results$diffexpressed == "Yes"] <- results$hgnc_symbol[results$diffexpressed == "Yes"]

results_goi = results %>%
  dplyr:: filter(ensembl_gene_id %in% genes_of_interest$ensembl_gene_id)

table(results$diffexpressed)

volcano.colors <- c("red", "black")
names(volcano.colors) <- c("Yes", "No")

#all genes
ggplot(results, aes(x=logFC, y=-log10(PValue), col=diffexpressed, label=DElabel)) +
  geom_point(size = 0.1) +
  scale_colour_manual(values = volcano.colors) +
  geom_point(data = results_goi, aes(x=logFC, y=-log10(PValue)), col = "blue", size = 0.1) +
  geom_text_repel(data = results_goi, aes(label=DElabel), col = "blue", size=3, max.overlaps = 10, show.legend = FALSE) +
  xlab("log2 fold change") +
  labs(col="Differentially expressed") +
  ggtitle("Heart LV vs AA, all genes")

#genes of interest only
ggplot(results_goi, aes(x=logFC, y=-log10(PValue), col=diffexpressed, label=DElabel)) +
  geom_point(size = 0.1) +
  geom_text_repel(size=3, max.overlaps = 10, show.legend = FALSE) +
  scale_colour_manual(values = volcano.colors) +
  xlab("log2 fold change") +
  labs(col="Differentially expressed") +
  ggtitle("Heart LV vs AA, genes of interest only")
```


#### boxplot gene of interest
```{r}
log_tpm_tmm_long_sample = log_tpm_tmm %>%
  as.data.frame() %>%
  rownames_to_column("ENSG") %>%
  pivot_longer(!ENSG, names_to = "sample", values_to = "log_tpm_tmm") %>%
  left_join(sample_meta, by = c("sample"="SAMPID"))

log_tpm_tmm_long_sample %>%
  filter(str_detect(ENSG, "ENSG00000166183")) %>%
  ggplot(aes(x = tissue, y = log_tpm_tmm, group = tissue)) +
  geom_violin(fill = "darkgrey")
```


### plot pval histogram
```{r}
#P.value histogram
ggplot(results, aes(x = PValue)) + 
  geom_histogram(binwidth = 0.025, boundary = 0) +
  ggtitle("p-value histogram: Heart LV vs AA, all genes")
```


### MA plot
```{r}
mycolors = c("black", "red")

ggplot(results, aes(x=logCPM, y=logFC, col=diffexpressed, label=DElabel)) + 
  geom_point(size=1) +
  geom_text_repel(size=2) +
  scale_colour_manual(values = mycolors) +
  xlab("logCPM") +
  ylab("log2 fold change") +
  ggtitle("MA plot, Heart LV vs AA, all genes") +
  geom_hline(yintercept=0) +
  geom_hline(yintercept=1, linetype="dashed") +
  geom_hline(yintercept=-1, linetype="dashed") +
  theme(plot.title = element_text(hjust = 0.5))

```


### QQ plot
```{r}
# qqt(fit$t, df=fit$df.prior+fit$df.residual,
#     pch=16,cex=0.2)
# abline(0,1, col="red", lwd=2)
```


## ANOVA for all tissues
```{r}
fit = glmQLFit(y, design, robust=TRUE)

qlf = glmQLFTest(fit, coef = 1:5)

results_aov = decideTestsDGE(qlf, adjust.method = "BH", p.value = 0.01, lfc = 5) #"p.value" is actually FDR

results_aov %>% 
  summary()
#############
#contrat matrix to explicitly state pairwaise comparisons
contrasts <- makeContrasts(
  (Heart_Atrial_Appendage + Heart_Left_Ventricle)/2 - (Kidney_Cortex + Liver + Muscle_Skeletal)/3,
  Kidney_Cortex- (Heart_Atrial_Appendage + Heart_Left_Ventricle + Liver + Muscle_Skeletal)/4,
  Liver- (Heart_Atrial_Appendage + Heart_Left_Ventricle + Kidney_Cortex + Muscle_Skeletal)/4,
  Muscle_Skeletal - (Heart_Atrial_Appendage + Heart_Left_Ventricle + Kidney_Cortex + Liver)/4,
  levels=colnames(design))

colnames(contrasts) <- c("Heart_vs_others", "Kidney_vs_others", "Liver_vs_others", "Muscle_vs_others")

qlf_contrasts = glmQLFTest(fit, contrast = contrasts)

edgeR_results_vs = qlf_contrasts$table %>%
  rownames_to_column("GTEx_ENSG") %>%
  left_join(qlf$genes, by = "GTEx_ENSG") %>%
  mutate(adj_PValue = p.adjust(PValue, method = "BH"))

edgeR_results_vs %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|"))) %>%
  filter(adj_PValue < 0.01 &
           (logFC.Heart_vs_others > 2))
```


### heatmap of genes significant in ANOVA
```{r}
# metabolic genes only
pval_threshold  = 0.01
logFC_treshold = 2

heart_vs_others_genes = edgeR_results_vs %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|"))) %>%
  filter(adj_PValue < pval_threshold  & (logFC.Heart_vs_others > logFC_treshold))
  
log_tpm_tmm_goi %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% heart_vs_others_genes$ensembl_gene_id) %>%
  column_to_rownames("GTEx_ENSG") %>%
pheatmap(scale = "none",
                   clustering_method = "ward.D2",
                   cluster_rows = T,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = T,
                   clustering_distance_cols = "euclidean",
                   show_rownames = TRUE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
         annotation_col=pheat_inf_col,
         annotation_names_col = FALSE,
                   main = "Heatmap of metabolic genes significantly alter in heart vs all other specified tissues")

heart_vs_others_genes %>%
  filter(ensembl_gene_id %in% genes_of_interest$ensembl_gene_id)


# all genes
log_tpm_tmm %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% heart_vs_others_genes$GTEx_ENSG) %>%
  column_to_rownames("GTEx_ENSG") %>%
pheatmap(scale = "none",
                   clustering_method = "ward.D2",
                   cluster_rows = T,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = T,
                   clustering_distance_cols = "euclidean",
                   show_rownames = TRUE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
         annotation_col=pheat_inf_col,
         annotation_names_col = FALSE,
                   main = "Heatmap of genes significantly alter in heart vs all other specified tissues")

# boxplot top hit logFC in genes of interest
log_tpm_tmm_long_sample %>%
  filter(str_detect(ENSG, "ENSG00000113396.12")) %>%
  ggplot(aes(x = tissue, y = log_tpm_tmm, group = tissue)) +
  geom_violin(fill = "darkgrey")

# plot another hit with high logFC
log_tpm_tmm_long_sample %>%
  filter(str_detect(ENSG, "ENSG00000156885.5")) %>%
  ggplot(aes(x = tissue, y = log_tpm_tmm, group = tissue)) +
  geom_violin(fill = "darkgrey")
```


### Programmatically produce results using for loop
```{r}
# metabolic genes only
for (i in colnames(contrasts)){
  name_genes <- paste0(i, "_genes") 
  assign(name_genes, edgeR_results_vs %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|"))) %>%
  filter(adj_PValue < pval_threshold & get(paste0("logFC.", i)) > logFC_treshold))
  
  name_metabolic_genes <- paste0(i, "_metabolic_genes") 
  assign(name_metabolic_genes, get(paste0(i, "_genes")) %>%
    filter(ensembl_gene_id %in% genes_of_interest$ensembl_gene_id))
  
  log_tpm_tmm_goi %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% get(paste0(i, "_genes"))$ensembl_gene_id) %>%
  column_to_rownames("GTEx_ENSG") %>%
pheatmap(scale = "none",
                   clustering_method = "ward.D2",
                   cluster_rows = T,
                   clustering_distance_rows = "euclidean",
                   cluster_cols = T,
                   clustering_distance_cols = "euclidean",
                  show_rownames = TRUE,
                   show_colnames = FALSE,
                   fontsize_row = 3,
                   fontsize_col = 5,
                   angle_col = 45,
         annotation_col=pheat_inf_col,
         annotation_names_col = FALSE,
                   main = paste0("Heatmap of metabolic genes significantly alter in: ", i))
  
  edgeR_results_vs[[paste0("DE_", i)]] <- if_else(edgeR_results_vs$adj_PValue < pval_threshold & paste0("edgeR_results_vs$logFC.", i) > logFC_treshold, TRUE, FALSE, missing = NA)
  
  # assign(edgeR_results_vs, edgeR_results_vs %>%
  #   mutate_(!!sym(paste0("DE_", i)) = if_else(adj_PValue < pval_threshold & !!sym(paste0("logFC.", i)) > logFC_treshold, 1, 0, missing = NA)))
  
}

```

```{r}
any_tissue_vs_others_genes = edgeR_results_vs %>%
  filter(str_detect(ensembl_gene_id, paste(protein_coding_genes, collapse = "|")) &
           adj_PValue < pval_threshold  & 
           (abs(logFC.Heart_vs_others) > logFC_treshold |
                                           abs(logFC.Kidney_vs_others) > logFC_treshold |
                                         abs(logFC.Liver_vs_others) > logFC_treshold |
                                           abs(logFC.Muscle_vs_others) > logFC_treshold))
  
log_tpm_tmm_goi %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% any_tissue_vs_others_genes$ensembl_gene_id) %>%
  column_to_rownames("GTEx_ENSG") %>%
pheatmap(scale = "row",
           clustering_method = "ward.D2",
           cluster_rows = T,
           clustering_distance_rows = "euclidean",
           cluster_cols = T,
           clustering_distance_cols = "euclidean",
           show_rownames = TRUE,
           fontsize_row = 3,
           fontsize_col = 5,
           angle_col = 45,
           annotation_col=pheat_inf_col,
           annotation_names_col = FALSE,
            main = "Heatmap of metabolic genes significantly alter in heart vs all other specified tissues")

test = log_tpm_tmm_goi %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% any_tissue_vs_others_genes$ensembl_gene_id) %>%
  column_to_rownames("GTEx_ENSG")

breaksList = seq(-3, 3, by= 0.2)
pheatmap(test, scale = "row",
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           breaks = breaksList,
           clustering_method = "ward.D2",
           cluster_rows = T,
           clustering_distance_rows = "euclidean",
           cluster_cols = T,
           clustering_distance_cols = "euclidean",
           show_rownames = TRUE,
         show_colnames = FALSE,
           fontsize_row = 3,
           fontsize_col = 5,
           angle_col = 45,
           annotation_col=pheat_inf_col,
           annotation_names_col = FALSE,
            main = "Heatmap of metabolic genes significantly alter in heart vs all other specified tissues")

test2 = log_tpm_grouped_tmm_goi %>%
  rownames_to_column("GTEx_ENSG") %>%
  filter(GTEx_ENSG %in% any_tissue_vs_others_genes$ensembl_gene_id) %>%
  column_to_rownames("GTEx_ENSG")

breaksList = seq(-4, 4, by= 0.2)
pheatmap(test2, scale = "row",
         #color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
           #breaks = breaksList,
           clustering_method = "ward.D2",
           cluster_rows = T,
           clustering_distance_rows = "euclidean",
           cluster_cols = T,
           clustering_distance_cols = "euclidean",
           show_rownames = TRUE,
         show_colnames = TRUE,
           fontsize_row = 3,
           fontsize_col = 5,
           angle_col = 45,
border_color = NA,
           #annotation_col=pheat_inf_col,
           annotation_names_col = FALSE,
            main = "Heatmap of metabolic genes significantly alter in heart vs all other specified tissues, z-score")
```



# tissue enrichment
see vignette: https://bioconductor.org/packages/release/bioc/vignettes/TissueEnrich/inst/doc/TissueEnrich.html#teenrichment-tissue-specific-gene-enrichment-using-human-or-mouse-genes
Has some useful viz options, but does not do what we want: to a priori define a list of tissue specific genes
To define tissue specificity in the first place, it uses the algorithm from the HPA: [@uhlen_2015]

HPA appraoch:
The genes are divided into six groups based on their gene expression across the tissues. These groups are:

Not Expressed: Genes with an expression level less than 1 (TPM or FPKM) across all the tissues.
Tissue Enriched: Genes with an expression level greater than or equal to 1 (TPM or FPKM) that also have at least five-fold higher expression levels in a particular tissue compared to all other tissues.
Group Enriched: Genes with an expression level greater than or equal to 1 (TPM or FPKM) that also have at least five-fold higher expression levels in a group of 2-7 tissues compared to all other tissues, and that are not considered Tissue Enriched.
Tissue Enhanced: Genes with an expression level greater than or equal to 1 (TPM or FPKM) that also have at least five-fold higher expression levels in a particular tissue compared to the average levels in all other tissues, and that are not considered Tissue Enriched or Group Enriched.
Expressed in all: Genes with an expression level greater than or equal to 1 (TPM or FPKM) across all of the tissues that are not in any of the above 4 groups.
Mixed: Genes that are not assigned to any of the above 5 groups.

This can be done with teGeneRetrieval from tissue enrich package
```{r}
library(TissueEnrich)

genes<-system.file("extdata", "inputGenes.txt", package = "TissueEnrich")
inputGenes<-scan(genes,character())

gs<-GeneSet(geneIds = unique(gene_info$hgnc_symbol), organism="Homo Sapiens", geneIdType=SymbolIdentifier())
output<-teEnrichment(inputGenes = gs)

seEnrichmentOutput<-output[[1]]
enrichmentOutput<-setNames(data.frame(assay(seEnrichmentOutput),row.names = rowData(seEnrichmentOutput)[,1]), colData(seEnrichmentOutput)[,1])
enrichmentOutput$Tissue<-row.names(enrichmentOutput)

```

```{r}
# # taken from teGeneRetrieval fucntion code
# expData <- setNames(assay(expressionData), colData(expressionData)[,1])
#     geneList <- as.list(rowData(expressionData)[, 1])
#     x <- lapply(seq(1, nrow(expData)), FUN = function(j) {
#         df <- c()
#         tpm <- expData[j, ]
#         gene <- j
#         tpm <- sort(tpm, decreasing = TRUE)
#         highTPM <- tpm[1]
# 
#         #### Check for Not Expressed
#         if (highTPM >= expressedGeneThreshold) {
#             secondHighTPM <- tpm[2]
#             foldChangeHigh <- highTPM/secondHighTPM
#             ### Check for Tissue Enriched
#             if (foldChangeHigh >= foldChangeThreshold) {
#                 df <- c(gene, names(tpm)[1], "Tissue-Enriched")
#             } else {
#                 #### Check for Group Enriched
#                 thresholdForGroupTPM <- highTPM/foldChangeThreshold
#                 groupTPM <- tpm[(tpm >= thresholdForGroupTPM) &
#                     (tpm >= expressedGeneThreshold), drop = FALSE]
#                 isFound <- FALSE
#                 if (length(groupTPM) <= maxNumberOfTissues &&
#                     length(groupTPM) >= minNumberOfTissues) {
#                         fc <- lapply(2:(length(groupTPM)),
#                         FUN = function(i) {
#                             meanTPMForGroup <- mean(groupTPM[seq(1, i)])
#                             highestTPMOutsideGroup <- tpm[i + 1]
#                             fc <- meanTPMForGroup/highestTPMOutsideGroup
#                             return(fc)
#                         })
# 
#                     idx <- (fc >= foldChangeThreshold)
#                     if (sum(idx) > 0) {
#                         index <- which.max(idx)
#                         x <- lapply(seq(1, (index + 1)),
#                             FUN = function(i) {
#                             c(gene, names(tpm)[i], "Group-Enriched") })
#                         df <- do.call("rbind", x)
#                         isFound <- TRUE
#                     }
#                 }
# 
#                 if (!isFound) {
#                     #### Check for Expressed In All
#                     if (all(tpm >= expressedGeneThreshold)) {
#                         df <- c(gene, "All", "Expressed-In-All")
#                     } else {
#                         #### Check for Tissue Enhanced
#                         tissueEnhancedThreshold <- mean(tpm) *
#                             foldChangeThreshold
#                         enhancedGene <- tpm[(tpm >= tissueEnhancedThreshold) &
#                             (tpm >= expressedGeneThreshold), drop = FALSE]
#                         if (length(enhancedGene) >= 1) {
#                             x <- lapply(names(enhancedGene),
#                                 FUN = function(enhancedTissue) {
#                                     c(gene, enhancedTissue, "Tissue-Enhanced")
#                                 })
#                             df <- do.call("rbind", x)
#                         } else {
#                             df <- c(gene, "All", "Mixed")
#                         }
#                     }
#                 }
#             }
#         } else {
#             df <- c(gene, "All", "Not-Expressed")
#         }
#         return(df)
#     })
# 
#     TSGenes <- do.call("rbind", x)
#     colnames(TSGenes) <- c("Gene", "Tissue", "Group")
#     TSGenes[, "Gene"] <- unlist(geneList[as.numeric(TSGenes[, "Gene"])])
```

